/**
 * PlaylistsService.js
 * 
 * Service layer for ALL playlist operations:
 * - CRUD orchestration (Firestore)
 * - Computation (stats, duration)
 * - Track operations (move, reorder, remove)
 * - Undo/Redo history
 * - LocalStorage persistence
 * - Export helpers
 * 
 * Extracted from PlaylistsStore (Sprint 19).
 */

import { PlaylistRepository } from '../repositories/PlaylistRepository.js'
import { writeBatch } from 'firebase/firestore'
import { playlistsStore } from '../stores/playlists.js'

const STORAGE_KEY = 'mjrp_current_playlists'
const MAX_VERSIONS = 20

export class PlaylistsService {
    constructor(db, cacheManager) {
        this.db = db
        this.cacheManager = cacheManager

        // Undo/Redo history
        this.versions = []
        this.currentVersionIndex = -1
    }

    // ========== TRACK OPERATIONS ==========

    moveTrack(fromPlaylistIndex, toPlaylistIndex, trackIndex, newIndex) {
        const playlists = [...playlistsStore.getPlaylists()]
        const fromPlaylist = playlists[fromPlaylistIndex]
        const toPlaylist = playlists[toPlaylistIndex]

        const [track] = fromPlaylist.tracks.splice(trackIndex, 1)
        toPlaylist.tracks.splice(newIndex, 0, track)

        this.createSnapshot(playlists, playlistsStore.getSeriesId(),
            `Moved track from ${fromPlaylist.name} to ${toPlaylist.name}`)

        playlistsStore.setPlaylists(playlists)
        playlistsStore.setDirty(true)
        playlistsStore.setSynchronized(false)
        this.saveToLocalStorage()
    }

    reorderTrack(playlistIndex, oldIndex, newIndex) {
        const playlists = [...playlistsStore.getPlaylists()]
        const playlist = playlists[playlistIndex]
        const [track] = playlist.tracks.splice(oldIndex, 1)
        playlist.tracks.splice(newIndex, 0, track)

        this.createSnapshot(playlists, playlistsStore.getSeriesId(),
            `Reordered track in ${playlist.name}`)

        playlistsStore.setPlaylists(playlists)
        playlistsStore.setDirty(true)
        playlistsStore.setSynchronized(false)
        this.saveToLocalStorage()
    }

    removeTrack(playlistIndex, trackIndex) {
        const playlists = [...playlistsStore.getPlaylists()]
        const playlist = playlists[playlistIndex]
        if (!playlist?.tracks) return

        const [removedTrack] = playlist.tracks.splice(trackIndex, 1)

        this.createSnapshot(playlists, playlistsStore.getSeriesId(),
            `Removed "${removedTrack.title}" from ${playlist.name}`)

        playlistsStore.setPlaylists(playlists)
        playlistsStore.setDirty(true)
        playlistsStore.setSynchronized(false)
        this.saveToLocalStorage()
    }

    // ========== COMPUTATION ==========

    calculateStats(playlists) {
        let totalTracks = 0
        let totalDuration = 0

        playlists.forEach(playlist => {
            if (playlist.tracks) {
                totalTracks += playlist.tracks.length
                totalDuration += playlist.tracks.reduce((sum, track) => {
                    return sum + (track.duration || track.durationSeconds || 0)
                }, 0)
            }
        })

        return { totalTracks, totalDuration: Math.round(totalDuration / 60) }
    }

    getPlaylistDuration(playlistIndex) {
        const playlist = playlistsStore.getPlaylists()[playlistIndex]
        if (!playlist?.tracks) return 0

        return playlist.tracks.reduce((total, track) => {
            return total + (track.duration || track.durationSeconds || 0)
        }, 0) / 60
    }

    prepareForExport(playlist) {
        return {
            name: playlist.name || playlist.title || 'Untitled Playlist',
            description: playlist.description || 'Generated by Album Blender',
            tracks: (playlist.tracks || []).map(track => ({
                title: track.title,
                artist: track.artist,
                duration: track.duration || track.durationSeconds,
                spotifyId: track.spotifyId || null,
                appleMusicId: track.appleMusicId || null
            }))
        }
    }

    // ========== MODE MANAGEMENT ==========

    setEditMode(batchName, seriesId, savedAt) {
        playlistsStore.setMode('EDITING')
        playlistsStore.setEditContext({
            originalBatchName: batchName,
            currentBatchName: batchName,
            seriesId,
            savedAt
        })
        playlistsStore.setBatchName(batchName)
        console.log('[PlaylistsService] Mode: EDITING')
    }

    setCreateMode() {
        playlistsStore.setMode('CREATING')
        playlistsStore.setEditContext(null)
        playlistsStore.setBatchName('')
        console.log('[PlaylistsService] Mode: CREATING')
    }

    applyBatchName(batchName) {
        const playlists = playlistsStore.getPlaylists()
        const timestamp = new Date().toISOString()

        playlists.forEach(playlist => {
            playlist.batchName = batchName
            playlist.savedAt = timestamp
        })

        playlistsStore.setBatchName(batchName)
        playlistsStore.setPlaylists(playlists)
    }

    // ========== UNDO/REDO ==========

    createSnapshot(playlists, seriesId, description) {
        if (this.currentVersionIndex < this.versions.length - 1) {
            this.versions = this.versions.slice(0, this.currentVersionIndex + 1)
        }

        this.versions.push({
            playlists: JSON.parse(JSON.stringify(playlists)),
            seriesId,
            timestamp: new Date().toISOString(),
            description
        })

        if (this.versions.length > MAX_VERSIONS) {
            this.versions.shift()
        }
        this.currentVersionIndex = this.versions.length - 1
        this.updateUndoState()
    }

    undo() {
        if (this.currentVersionIndex > 0) {
            this.currentVersionIndex--
            const version = this.versions[this.currentVersionIndex]
            playlistsStore.setPlaylists(
                JSON.parse(JSON.stringify(version.playlists)),
                version.seriesId
            )
            playlistsStore.setDirty(true)
            this.updateUndoState()
            return true
        }
        return false
    }

    redo() {
        if (this.currentVersionIndex < this.versions.length - 1) {
            this.currentVersionIndex++
            const version = this.versions[this.currentVersionIndex]
            playlistsStore.setPlaylists(
                JSON.parse(JSON.stringify(version.playlists)),
                version.seriesId
            )
            playlistsStore.setDirty(true)
            this.updateUndoState()
            return true
        }
        return false
    }

    updateUndoState() {
        playlistsStore.setUndoState(
            this.currentVersionIndex > 0,
            this.currentVersionIndex < this.versions.length - 1
        )
    }

    // ========== LOCALSTORAGE ==========

    saveToLocalStorage() {
        const state = playlistsStore.getState()
        if (!state.seriesId) return

        try {
            const data = {
                playlists: JSON.parse(JSON.stringify(state.playlists)),
                seriesId: state.seriesId,
                config: state.config,
                mode: state.mode,
                editContext: state.editContext,
                batchName: state.batchName,
                defaultBatchName: state.defaultBatchName,
                timestamp: Date.now()
            }
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data))
        } catch (e) {
            console.warn('Failed to save to LocalStorage:', e)
        }
    }

    loadFromLocalStorage() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY)
            if (!saved) return false

            const data = JSON.parse(saved)

            playlistsStore.setPlaylists(data.playlists || [], data.seriesId)
            playlistsStore.setConfig(data.config || {})
            playlistsStore.setMode(data.mode || 'CREATING')
            playlistsStore.setEditContext(data.editContext || null)
            playlistsStore.setBatchName(data.batchName || '')
            playlistsStore.setDefaultBatchName(data.defaultBatchName || null)
            playlistsStore.setDirty(false)

            return true
        } catch (e) {
            console.warn('Failed to load from LocalStorage:', e)
            return false
        }
    }

    clearLocalStorage() {
        localStorage.removeItem(STORAGE_KEY)
    }

    // ========== FIRESTORE CRUD ==========

    async saveBatch(userId, seriesId, playlists) {
        if (!seriesId || !this.db) {
            throw new Error('Cannot save: Missing database or Series ID')
        }

        const repo = new PlaylistRepository(this.db, this.cacheManager, userId || 'anonymous-user', seriesId)
        const batch = writeBatch(this.db)
        const sanitized = JSON.parse(JSON.stringify(playlists))

        const saved = await Promise.all(
            sanitized.map(async (playlist, index) => {
                const data = { ...playlist, order: index, updatedAt: new Date().toISOString() }
                if (playlist.id) {
                    await repo.save(playlist.id, data, batch)
                    return { ...data, id: playlist.id }
                } else {
                    const newId = await repo.create(data, batch)
                    return { ...data, id: newId }
                }
            })
        )

        await batch.commit()
        console.log('[PlaylistsService] Batch save successful')

        playlistsStore.setPlaylists(saved, seriesId)
        playlistsStore.setDirty(false)
        playlistsStore.setSynchronized(true)
        this.saveToLocalStorage()

        return saved
    }

    async loadBatch(userId, seriesId) {
        if (!seriesId || !this.db) return []

        const repo = new PlaylistRepository(this.db, this.cacheManager, userId || 'anonymous-user', seriesId)
        const playlists = await repo.findAll()

        if (playlists?.length > 0) {
            playlistsStore.setPlaylists(playlists, seriesId)
            playlistsStore.setSynchronized(true)
            playlistsStore.setDirty(false)
            this.saveToLocalStorage()
        }

        return playlists || []
    }

    async deleteBatch(userId, seriesId, batchName) {
        if (!seriesId || !this.db) {
            throw new Error('Cannot delete: Missing database or Series ID')
        }

        const repo = new PlaylistRepository(this.db, this.cacheManager, userId || 'anonymous-user', seriesId)
        const all = await repo.findAll()
        const toDelete = all.filter(p => p.batchName === batchName)
        const batch = writeBatch(this.db)

        for (const playlist of toDelete) {
            await repo.delete(playlist.id, batch)
        }

        await batch.commit()
        console.log(`[PlaylistsService] Deleted ${toDelete.length} playlists`)
    }

    // ========== INITIALIZATION ==========

    initializeWithPlaylists(playlists, seriesId) {
        this.createSnapshot(playlists, seriesId, 'Initial generation')
        playlistsStore.setPlaylists(playlists, seriesId)
        playlistsStore.setDirty(false)
        playlistsStore.setSynchronized(false)
        this.saveToLocalStorage()
    }

    reset() {
        this.versions = []
        this.currentVersionIndex = -1
        this.clearLocalStorage()
        playlistsStore.reset()
    }
}

// Singleton factory
let _instance = null

export function getPlaylistsService(db, cacheManager) {
    if (!_instance && db) {
        _instance = new PlaylistsService(db, cacheManager)
    }
    return _instance
}
