/**
 * PlaylistsService.js
 * 
 * Service layer for playlist operations (CRUD, computation, export).
 * Extracted from PlaylistsStore to achieve separation of concerns.
 * 
 * @module services/PlaylistsService
 */

import { PlaylistRepository } from '../repositories/PlaylistRepository.js'
import { writeBatch } from 'firebase/firestore'

export class PlaylistsService {
    /**
     * @param {Object} db - Firestore instance
     * @param {Object} cacheManager - Cache manager instance
     */
    constructor(db, cacheManager) {
        this.db = db
        this.cacheManager = cacheManager
    }

    // ========== COMPUTATION ==========

    /**
     * Calculate aggregate stats for a set of playlists
     * @param {Array} playlists - Array of playlist objects
     * @returns {{ totalTracks: number, totalDuration: number }}
     */
    calculateStats(playlists) {
        let totalTracks = 0
        let totalDuration = 0

        playlists.forEach(playlist => {
            if (playlist.tracks) {
                totalTracks += playlist.tracks.length
                totalDuration += playlist.tracks.reduce((sum, track) => {
                    const duration = track.duration || track.durationSeconds || 0
                    return sum + duration
                }, 0)
            }
        })

        return {
            totalTracks,
            totalDuration: Math.round(totalDuration / 60) // Convert to minutes
        }
    }

    /**
     * Prepare a playlist for export (sanitize, transform)
     * @param {Object} playlist - Playlist object
     * @returns {Object} Export-ready payload
     */
    prepareForExport(playlist) {
        return {
            name: playlist.name || playlist.title || 'Untitled Playlist',
            description: playlist.description || `Generated by Album Blender`,
            tracks: (playlist.tracks || []).map(track => ({
                title: track.title,
                artist: track.artist,
                duration: track.duration || track.durationSeconds,
                spotifyId: track.spotifyId || null,
                appleMusicId: track.appleMusicId || null
            }))
        }
    }

    // ========== CRUD ORCHESTRATION ==========

    /**
     * Save a batch of playlists to Firestore (atomic)
     * @param {string} userId - Current user ID
     * @param {string} seriesId - Series ID
     * @param {Array} playlists - Playlists to save
     * @returns {Promise<Array>} Saved playlists with IDs
     */
    async saveBatch(userId, seriesId, playlists) {
        if (!seriesId || !this.db) {
            throw new Error('Cannot save: Missing database connection or Series ID')
        }

        const repo = new PlaylistRepository(
            this.db,
            this.cacheManager,
            userId || 'anonymous-user',
            seriesId
        )

        const batch = writeBatch(this.db)

        // Sanitize data (deep clean via JSON serialization)
        const sanitizedPlaylists = JSON.parse(JSON.stringify(playlists))

        // Add operations to batch
        const savedPlaylists = await Promise.all(
            sanitizedPlaylists.map(async (playlist, index) => {
                const playlistData = {
                    ...playlist,
                    order: index,
                    updatedAt: new Date().toISOString()
                }

                if (playlist.id) {
                    await repo.save(playlist.id, playlistData, batch)
                    return { ...playlistData, id: playlist.id }
                } else {
                    const newId = await repo.create(playlistData, batch)
                    return { ...playlistData, id: newId }
                }
            })
        )

        // Commit batch transaction
        try {
            await batch.commit()
            console.log('[PlaylistsService] Batch save successful')
            return savedPlaylists
        } catch (err) {
            console.error('[PlaylistsService] Batch save FAILED', err)
            throw new Error('Failed to save playlists. Please check your connection and try again.')
        }
    }

    /**
     * Load playlists from Firestore for a series
     * @param {string} userId - Current user ID
     * @param {string} seriesId - Series ID to load
     * @returns {Promise<Array>} Loaded playlists
     */
    async loadBatch(userId, seriesId) {
        if (!seriesId || !this.db) {
            return []
        }

        const repo = new PlaylistRepository(
            this.db,
            this.cacheManager,
            userId || 'anonymous-user',
            seriesId
        )

        const playlists = await repo.findAll()
        return playlists || []
    }

    /**
     * Delete all playlists in a batch
     * @param {string} userId - Current user ID
     * @param {string} seriesId - Series ID
     * @param {string} batchName - Batch name to delete
     * @returns {Promise<void>}
     */
    async deleteBatch(userId, seriesId, batchName) {
        if (!seriesId || !this.db) {
            throw new Error('Cannot delete: Missing database connection or Series ID')
        }

        const repo = new PlaylistRepository(
            this.db,
            this.cacheManager,
            userId || 'anonymous-user',
            seriesId
        )

        // Find all playlists with matching batchName
        const allPlaylists = await repo.findAll()
        const toDelete = allPlaylists.filter(p => p.batchName === batchName)

        const batch = writeBatch(this.db)

        for (const playlist of toDelete) {
            await repo.delete(playlist.id, batch)
        }

        await batch.commit()
        console.log(`[PlaylistsService] Deleted ${toDelete.length} playlists from batch "${batchName}"`)
    }
}

// Singleton factory (lazy initialization)
let _instance = null

/**
 * Get or create PlaylistsService singleton
 * @param {Object} db - Firestore instance
 * @param {Object} cacheManager - Cache manager
 * @returns {PlaylistsService}
 */
export function getPlaylistsService(db, cacheManager) {
    if (!_instance && db) {
        _instance = new PlaylistsService(db, cacheManager)
    }
    return _instance
}
