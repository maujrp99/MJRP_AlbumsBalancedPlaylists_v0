/**
 * PlaylistsService.js
 * 
 * Service layer for ALL playlist operations:
 * - CRUD orchestration (Firestore)
 * - Computation (stats, duration)
 * - Track operations (move, reorder, remove)
 * - Undo/Redo history
 * - LocalStorage persistence
 * - Export helpers
 * 
 * Extracted from PlaylistsStore (Sprint 19).
 * Refactored for modularity (Track C).
 */

import { PlaylistRepository } from '../repositories/PlaylistRepository.js'
import { writeBatch } from 'firebase/firestore'
import { playlistsStore } from '../stores/playlists.js'
import { StorageService } from './infra/StorageService.js'
import { PlaylistHistoryService } from './playlists/PlaylistHistoryService.js'

const STORAGE_KEY = 'current_playlists' // prefix will be added by service

export class PlaylistsService {
    constructor(db, cacheManager, storageService, historyService) {
        this.db = db
        this.cacheManager = cacheManager

        // Dependencies
        this.storage = storageService || new StorageService()
        this.history = historyService || new PlaylistHistoryService()
    }

    // ========== TRACK OPERATIONS ==========

    moveTrack(fromPlaylistIndex, toPlaylistIndex, trackIndex, newIndex) {
        const playlists = [...playlistsStore.getPlaylists()]
        const fromPlaylist = playlists[fromPlaylistIndex]
        const toPlaylist = playlists[toPlaylistIndex]
        const seriesId = playlistsStore.getSeriesId()

        const [track] = fromPlaylist.tracks.splice(trackIndex, 1)
        toPlaylist.tracks.splice(newIndex, 0, track)

        this.history.createSnapshot(playlists, seriesId,
            `Moved track from ${fromPlaylist.name} to ${toPlaylist.name}`)

        this._updateState(playlists, seriesId)
    }

    reorderTrack(playlistIndex, oldIndex, newIndex) {
        const playlists = [...playlistsStore.getPlaylists()]
        const playlist = playlists[playlistIndex]
        const seriesId = playlistsStore.getSeriesId()

        const [track] = playlist.tracks.splice(oldIndex, 1)
        playlist.tracks.splice(newIndex, 0, track)

        this.history.createSnapshot(playlists, seriesId,
            `Reordered track in ${playlist.name}`)

        this._updateState(playlists, seriesId)
    }

    removeTrack(playlistIndex, trackIndex) {
        const playlists = [...playlistsStore.getPlaylists()]
        const playlist = playlists[playlistIndex]
        const seriesId = playlistsStore.getSeriesId()

        if (!playlist?.tracks) return

        const [removedTrack] = playlist.tracks.splice(trackIndex, 1)

        this.history.createSnapshot(playlists, seriesId,
            `Removed "${removedTrack.title}" from ${playlist.name}`)

        this._updateState(playlists, seriesId)
    }

    _updateState(playlists, seriesId) {
        playlistsStore.setPlaylists(playlists, seriesId)
        playlistsStore.setDirty(true)
        playlistsStore.setSynchronized(false)
        this.saveToLocalStorage()
    }

    // ========== COMPUTATION ==========

    calculateStats(playlists) {
        let totalTracks = 0
        let totalDuration = 0

        playlists.forEach(playlist => {
            if (playlist.tracks) {
                totalTracks += playlist.tracks.length
                totalDuration += playlist.tracks.reduce((sum, track) => {
                    return sum + (track.duration || track.durationSeconds || 0)
                }, 0)
            }
        })

        return { totalTracks, totalDuration: Math.round(totalDuration / 60) }
    }

    getPlaylistDuration(playlistIndex) {
        const playlist = playlistsStore.getPlaylists()[playlistIndex]
        if (!playlist?.tracks) return 0

        return playlist.tracks.reduce((total, track) => {
            return total + (track.duration || track.durationSeconds || 0)
        }, 0) / 60
    }

    prepareForExport(playlist) {
        return {
            name: playlist.name || playlist.title || 'Untitled Playlist',
            description: playlist.description || 'Generated by Album Blender',
            tracks: (playlist.tracks || []).map(track => ({
                title: track.title,
                artist: track.artist,
                duration: track.duration || track.durationSeconds,
                spotifyId: track.spotifyId || null,
                appleMusicId: track.appleMusicId || null
            }))
        }
    }

    // ========== MODE MANAGEMENT ==========

    setEditMode(batchName, seriesId, savedAt) {
        playlistsStore.setMode('EDITING')
        playlistsStore.setEditContext({
            originalBatchName: batchName,
            currentBatchName: batchName,
            seriesId,
            savedAt
        })
        playlistsStore.setBatchName(batchName)
        console.log('[PlaylistsService] Mode: EDITING')
    }

    setCreateMode() {
        playlistsStore.setMode('CREATING')
        playlistsStore.setEditContext(null)
        playlistsStore.setBatchName('')
        console.log('[PlaylistsService] Mode: CREATING')
    }

    applyBatchName(batchName) {
        const playlists = playlistsStore.getPlaylists()
        const timestamp = new Date().toISOString()

        playlists.forEach(playlist => {
            playlist.batchName = batchName
            playlist.savedAt = timestamp
        })

        playlistsStore.setBatchName(batchName)
        playlistsStore.setPlaylists(playlists)
    }

    // ========== UNDO/REDO (Delegated) ==========

    createSnapshot(playlists, seriesId, description) {
        this.history.createSnapshot(playlists, seriesId, description)
        this.updateUndoState()
    }

    undo() {
        const state = this.history.undo()
        if (state) {
            playlistsStore.setPlaylists(state.playlists, state.seriesId)
            playlistsStore.setDirty(true)
            this.updateUndoState()
            return true
        }
        return false
    }

    redo() {
        const state = this.history.redo()
        if (state) {
            playlistsStore.setPlaylists(state.playlists, state.seriesId)
            playlistsStore.setDirty(true)
            this.updateUndoState()
            return true
        }
        return false
    }

    updateUndoState() {
        const stats = this.history.getStats()
        playlistsStore.setUndoState(stats.canUndo, stats.canRedo)
    }

    // ========== LOCALSTORAGE (Delegated) ==========

    saveToLocalStorage() {
        const state = playlistsStore.getState()
        if (!state.seriesId) return

        const data = {
            playlists: state.playlists, // Store is pure, safe to save directly
            seriesId: state.seriesId,
            config: state.config,
            mode: state.mode,
            editContext: state.editContext,
            batchName: state.batchName,
            defaultBatchName: state.defaultBatchName,
            timestamp: Date.now()
        }

        this.storage.save(STORAGE_KEY, data)
    }

    loadFromLocalStorage() {
        const data = this.storage.load(STORAGE_KEY)
        if (!data) return false

        playlistsStore.setPlaylists(data.playlists || [], data.seriesId)
        playlistsStore.setConfig(data.config || {})
        playlistsStore.setMode(data.mode || 'CREATING')
        playlistsStore.setEditContext(data.editContext || null)
        playlistsStore.setBatchName(data.batchName || '')
        playlistsStore.setDefaultBatchName(data.defaultBatchName || null)
        playlistsStore.setDirty(false)

        return true
    }

    clearLocalStorage() {
        this.storage.remove(STORAGE_KEY)
    }

    // ========== FIRESTORE CRUD ==========

    async saveBatch(userId, seriesId, playlists) {
        if (!seriesId || !this.db) {
            throw new Error('Cannot save: Missing database or Series ID')
        }

        const repo = new PlaylistRepository(this.db, this.cacheManager, userId || 'anonymous-user', seriesId)
        const batch = writeBatch(this.db)
        const sanitized = JSON.parse(JSON.stringify(playlists))

        const saved = await Promise.all(
            sanitized.map(async (playlist, index) => {
                const data = { ...playlist, order: index, updatedAt: new Date().toISOString() }
                if (playlist.id) {
                    await repo.save(playlist.id, data, batch)
                    return { ...data, id: playlist.id }
                } else {
                    const newId = await repo.create(data, batch)
                    return { ...data, id: newId }
                }
            })
        )

        await batch.commit()
        console.log('[PlaylistsService] Batch save successful')

        playlistsStore.setPlaylists(saved, seriesId)
        playlistsStore.setDirty(false)
        playlistsStore.setSynchronized(true)
        this.saveToLocalStorage()

        return saved
    }

    async loadBatch(userId, seriesId) {
        if (!seriesId || !this.db) return []

        const repo = new PlaylistRepository(this.db, this.cacheManager, userId || 'anonymous-user', seriesId)
        const playlists = await repo.findAll()

        if (playlists?.length > 0) {
            playlistsStore.setPlaylists(playlists, seriesId)
            playlistsStore.setSynchronized(true)
            playlistsStore.setDirty(false)
            this.saveToLocalStorage()
        }

        return playlists || []
    }

    async deleteBatch(userId, seriesId, batchName) {
        if (!seriesId || !this.db) {
            throw new Error('Cannot delete: Missing database or Series ID')
        }

        const repo = new PlaylistRepository(this.db, this.cacheManager, userId || 'anonymous-user', seriesId)
        const all = await repo.findAll()
        const toDelete = all.filter(p => p.batchName === batchName)
        const batch = writeBatch(this.db)

        for (const playlist of toDelete) {
            await repo.delete(playlist.id, batch)
        }

        await batch.commit()
        console.log(`[PlaylistsService] Deleted ${toDelete.length} playlists`)
    }

    // ========== INITIALIZATION ==========

    initializeWithPlaylists(playlists, seriesId) {
        this.history.clear() // Reset history on new init
        this.createSnapshot(playlists, seriesId, 'Initial generation')
        playlistsStore.setPlaylists(playlists, seriesId)
        playlistsStore.setDirty(false)
        playlistsStore.setSynchronized(false)
        this.saveToLocalStorage()
    }

    reset() {
        this.history.clear()
        this.clearLocalStorage()
        playlistsStore.reset()
    }
}

// Singleton factory
let _instance = null

export function getPlaylistsService(db, cacheManager) {
    if (!_instance && db) {
        const storage = new StorageService()
        const history = new PlaylistHistoryService()
        _instance = new PlaylistsService(db, cacheManager, storage, history)
    }
    return _instance
}
