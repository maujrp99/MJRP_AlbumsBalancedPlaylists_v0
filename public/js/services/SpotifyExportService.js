/**
 * SpotifyExportService.js
 * 
 * Handles the logic for exporting playlists to Spotify.
 * Extracted from SpotifyExportModal.js (sprint-18-frontend-refactor).
 * 
 * Responsibilities:
 * - Orchestrate the Export Workflow (Match -> Create -> Add)
 * - Rate Limiting
 * - Progress Reporting
 */

import { SpotifyAuthService } from './SpotifyAuthService.js';
import { SpotifyService } from './SpotifyService.js';

export class SpotifyExportService {

    /**
     * Export playlists to Spotify
     * @param {Array} playlists - Array of playlist objects from store
     * @param {Object} options - { mode: 'merge'|'separate', name: string }
     * @param {Object} callbacks - { onProgress: (stage, current, total, message) => void, onMatch: (count) => void, onNotFound: (track) => void }
     * @returns {Promise<Object>} Result { matchCount, totalTracks, createdUrl }
     */
    static async exportPlaylists(playlists, options, callbacks) {
        const { mode, name } = options;
        const { onProgress, onMatch, onNotFound } = callbacks;

        // Check auth
        if (!SpotifyAuthService.isAuthenticated()) {
            throw new Error('Connect to Spotify first');
        }

        if (!playlists || playlists.length === 0) {
            throw new Error('No playlists to export');
        }

        // Calculate total tracks
        const totalTracks = playlists.reduce((sum, p) => sum + (p.tracks?.length || 0), 0);
        let processedTracks = 0;
        let matchCount = 0;

        // Structure to hold matched URIs per playlist
        const playlistMatches = playlists.map(p => ({
            name: p.name,
            uris: []
        }));

        // Phase 1: MATCHING
        for (let i = 0; i < playlists.length; i++) {
            const playlist = playlists[i];
            for (const track of (playlist.tracks || [])) {
                processedTracks++;
                onProgress('MATCHING', processedTracks, totalTracks, `Searching: ${track.title || track.name}`);

                try {
                    const found = await SpotifyService.searchTrack(
                        track.title || track.name,
                        track.artist,
                        track.album || ''
                    );

                    if (found) {
                        playlistMatches[i].uris.push(found.uri);
                        matchCount++;
                        if (onMatch) onMatch(matchCount);
                    } else {
                        if (onNotFound) onNotFound({
                            title: track.title || track.name,
                            artist: track.artist,
                            playlist: playlist.title || playlist.name
                        });
                    }
                } catch (e) {
                    console.warn('Track search failed', e);
                }

                // Rate limiting
                await new Promise(r => setTimeout(r, 80));
            }
        }

        if (matchCount === 0) {
            throw new Error('No tracks found on Spotify');
        }

        // Phase 2: CREATING & ADDING
        let createdUrl = null;

        if (mode === 'separate') {
            onProgress('CREATING', 0, playlists.length, `Creating ${playlists.length} separate playlists...`);

            // Create array of { name, tracks: [uris] }
            const exportData = playlistMatches.map(pm => ({
                name: pm.name,
                tracks: pm.uris.map(uri => ({ spotifyUri: uri }))
            }));

            await SpotifyService.createSeriesPlaylists(
                exportData,
                name, // Series name prefix
                (curr, total, msg) => {
                    onProgress('CREATING', curr, total, msg);
                }
            );

        } else {
            // MERGE MODE
            onProgress('CREATING', 0, 1, `Creating "${name}"...`);

            const description = `Generated by MJRP Album Blender â€¢ ${matchCount}/${totalTracks} tracks`;
            const createdPlaylist = await SpotifyService.createPlaylist(name, description);

            // Flatten all URIs
            const allTrackUris = playlistMatches.flatMap(pm => pm.uris);

            // Phase 3: ADDING
            onProgress('ADDING', 0, allTrackUris.length, `Adding ${allTrackUris.length} tracks...`);

            await SpotifyService.addTracksToPlaylist(createdPlaylist.id, allTrackUris);

            createdUrl = createdPlaylist.external_urls?.spotify || `https://open.spotify.com/playlist/${createdPlaylist.id}`;
        }

        return {
            matchCount,
            totalTracks,
            createdUrl
        };
    }
}
