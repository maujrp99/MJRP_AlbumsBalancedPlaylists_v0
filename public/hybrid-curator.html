<!DOCTYPE html>
<html lang="pt-br" class="h-full bg-gray-900">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- T√≠tulo e Favicon (√çcone) -->
    <title>Curadoria H√≠brida</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üéµ</text></svg>">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Font Inter -->
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">

    <!-- Configura√ß√£o do Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'spotify-green': '#1DB954',
                        'spotify-dark': '#121212',
                        'spotify-lightdark': '#181818',
                        'spotify-gray': '#282828',
                        'spotify-lightgray': '#B3B3B3',
                    }
                }
            }
        }
    </script>

    <!-- CSS Customizado -->
    <style>
        /* Estilo base */
        body {
            font-family: 'Inter', sans-serif;
            color: #E0E0E0;
        }

        /* Ajuste para altura total em todos os dispositivos */
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            /* Evita scroll horizontal */
        }

        /* Container principal com scroll vertical se necess√°rio */
        #app-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background-color: #000;
        }

        /* Header fixo no topo */
        header {
            position: sticky;
            top: 0;
            z-index: 50;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid #282828;
        }

        /* Conte√∫do principal com padding */
        #main-content {
            flex-grow: 1;
            padding: 1.5rem;
        }

        /* Grid responsivo para √Ålbuns e Playlists */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        /* Efeito de "ghost" (fantasma) para o item sendo arrastado */
        .sortable-ghost {
            opacity: 0.4;
            background-color: #4CAF50;
            border-radius: 8px;
        }

        /* Efeito no item que est√° sendo arrastado */
        .sortable-drag {
            opacity: 0.9;
        }

        /* Estilo da faixa de m√∫sica (draggable item) */
        .track-item {
            cursor: grab;
            transition: background-color 0.2s;
        }

        .track-item:active {
            cursor: grabbing;
        }

        /* Scrollbar customizada (para Webkit: Chrome, Safari) */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #181818;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Spinner de Loading */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-left-color: #1DB954;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Classe de estado de loading */
        .loading {
            pointer-events: none;
            opacity: 0.7;
        }

        /* Modal (Passo 1) */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #181818;
            border: 1px solid #282828;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .modal-body {
            overflow-y: auto;
        }

        /* Fim Modal */
    </style>
</head>

<body class="h-full antialiased">

    <!-- Container principal do App -->
    <div id="app-container">

        <!-- Header Fixo -->
        <header class="p-4 shadow-lg">
            <div class="container mx-auto flex items-center justify-between max-w-7xl">
                <!-- Logo -->
                <div class="flex items-center space-x-3">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-spotify-green" fill="none"
                        viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M9 19V6l12-3v13M9 19c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2zm12-3c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z" />
                    </svg>
                    <h1 class="text-xl font-bold text-white tracking-tight">Curadoria H√≠brida</h1>
                </div>

                <!-- Bot√µes de A√ß√£o -->
                <div class="flex items-center space-x-3">
                    <!-- (Passo 1) Bot√£o Carregar Dados -->
                    <button id="loadDataBtn"
                        class="bg-gray-700 text-white px-4 py-2 rounded-full font-semibold text-sm hover:bg-gray-600 transition-colors">
                        Carregar Dados
                    </button>
                    <!-- Bot√£o de "Toggle View" -->
                    <button id="toggleViewBtn"
                        class="bg-gray-700 text-white px-4 py-2 rounded-full font-semibold text-sm hover:bg-gray-600 transition-colors">
                        Ver Playlists
                    </button>
                    <!-- Bot√£o Salvar -->
                    <button id="saveBtn"
                        class="bg-spotify-green text-black px-5 py-2 rounded-full font-bold text-sm hover:bg-green-400 transition-colors flex items-center space-x-2">
                        <svg id="save-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none"
                            viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                        </svg>
                        <span id="save-text">Salvar</span>
                    </button>
                </div>
            </div>
        </header>

        <!-- Conte√∫do Principal (√Ålbuns ou Playlists) -->
        <main id="main-content" class="container mx-auto max-w-7xl p-4 md:p-6">

            <!-- Tela de Loading Inicial -->
            <div id="loading-spinner" class="flex flex-col items-center justify-center p-16">
                <div class="spinner"></div>
                <p class="mt-4 text-spotify-lightgray">Carregando dados do Firestore...</p>
            </div>

            <!-- View dos √Ålbuns (Default) -->
            <section id="albums-view" class="hidden">
                <h2 class="text-3xl font-bold text-white mb-6">√Ålbuns (Origem)</h2>

                <!-- Resumo de Verifica√ß√£o (√Ålbuns) -->
                <div id="albums-summary" class="bg-spotify-gray p-4 rounded-lg mb-6 shadow-md">
                    <!-- O conte√∫do ser√° injetado pelo JS -->
                </div>

                <!-- Bot√£o Gerar Playlists -->
                <div class="text-center my-6">
                    <button id="generateBtn"
                        class="bg-spotify-green text-black px-8 py-3 rounded-full font-bold text-lg hover:bg-green-400 transition-colors shadow-lg">
                        Gerar Playlists (Algoritmo H√≠brido)
                    </button>
                </div>

                <!-- Grid de √Ålbuns -->
                <div id="albums-grid" class="card-grid">
                    <!-- Cards de √Ålbuns ser√£o injetados pelo JS -->
                </div>
            </section>

            <!-- View das Playlists -->
            <section id="playlists-view" class="hidden">
                <h2 class="text-3xl font-bold text-white mb-6">Playlists Geradas</h2>

                <!-- Resumo de Verifica√ß√£o (Playlists) -->
                <div id="playlists-summary" class="bg-spotify-gray p-4 rounded-lg mb-6 shadow-md">
                    <!-- O conte√∫do ser√° injetado pelo JS -->
                </div>

                <!-- Grid de Playlists -->
                <div id="playlists-grid" class="card-grid">
                    <!-- Cards de Playlists ser√£o injetados pelo JS -->
                </div>
            </section>
        </main>
    </div>

    <!-- (Passo 1) Modal de Carregar Dados -->
    <div id="dataModal" class="modal hidden">
        <div class="modal-content rounded-lg shadow-xl">
            <!-- Header do Modal -->
            <div class="p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-lg font-semibold text-white">Carregar Dados dos √Ålbuns (JSON)</h3>
                <!-- (Passo 2) Bot√£o Fechar (X) -->
                <button id="closeModalBtn" class="text-gray-400 hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>

            <!-- Body do Modal (com o input) -->
            <div class="modal-body p-4">
                <p class="text-sm text-gray-400 mb-2">
                    Cole o JSON da sua lista de √°lbuns abaixo. Use a estrutura do template como guia.
                    O ranking das faixas √© essencial para o algoritmo.
                </p>
                <!-- (Passo 1) Caixa de Texto -->
                <textarea id="jsonInput"
                    class="w-full h-64 bg-gray-900 border border-gray-700 rounded-md p-3 text-sm font-mono text-white focus:outline-none focus:ring-2 focus:ring-spotify-green"
                    spellcheck="false"></textarea>
                <!-- (Passo 3) Mensagem de Erro -->
                <p id="jsonError" class="text-red-400 text-sm mt-2 font-medium"></p>
            </div>

            <!-- Footer do Modal (Bot√µes) -->
            <div class="p-4 border-t border-gray-700 bg-gray-800 rounded-b-lg flex justify-end space-x-3">
                <!-- (Passo 2) Bot√£o Cancelar -->
                <button id="cancelModalBtn"
                    class="bg-gray-600 text-white px-4 py-2 rounded-full font-semibold text-sm hover:bg-gray-500 transition-colors">
                    Cancelar
                </button>
                <!-- (Passo 3) Bot√£o Processar -->
                <button id="processJsonBtn"
                    class="bg-spotify-green text-black px-4 py-2 rounded-full font-bold text-sm hover:bg-green-400 transition-colors">
                    Processar e Salvar
                </button>
            </div>
        </div>
    </div>


    <!-- Biblioteca SortableJS (Drag-and-Drop) -->
    <!-- Movido para o final do Body e com 'defer' para garantir o carregamento antes do script do app -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js" defer></script>

    <!-- Firebase (M√≥dulo) -->
    <script src="firebase-config.js"></script>
    <script type="module">
        // Importa√ß√µes do Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configura√ß√£o Firebase ---
        console.log("Module script start. window.__firebase_config:", window.__firebase_config);
        const rawConfig = window.__firebase_config || (typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const firebaseConfig = typeof rawConfig === 'string' ? JSON.parse(rawConfig) : rawConfig;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let app, auth, db;
        let userId;

        // Refer√™ncias dos Documentos do Firestore
        let albumsDocRef;
        let playlistsDocRef;

        // Estado Global da Aplica√ß√£o
        let currentAlbums = [];
        let currentPlaylists = [];
        let isAlbumsView = true;
        let sortableInstances = []; // Array para guardar inst√¢ncias do Sortable
        let unsubscribeAlbums = null; // Listener do Firestore
        let unsubscribePlaylists = null; // Listener do Firestore

        // --- Elementos da UI ---
        // (Declarados aqui para acesso global no script)
        let mainContent, loadingSpinner, albumsView, playlistsView, albumsGrid, playlistsGrid;
        let toggleViewBtn, generateBtn, saveBtn, saveText, saveIcon;
        let albumsSummary, playlistsSummary;

        // Elementos do Modal (Passos 1-3)
        let loadDataBtn, dataModal, closeModalBtn, cancelModalBtn, processJsonBtn, jsonInput, jsonError;

        // (Passo 6) Template JSON para guiar novos usu√°rios
        const jsonTemplate = [
            {
                "id": "album_1",
                "artist": "Nome do Artista",
                "title": "Nome do √Ålbum",
                "year": 2024,
                "cover": "https://placehold.co/300x300/333/888?text=Capa",
                "tracks": [
                    {
                        "id": "t1_1",
                        "rank": 1,
                        "title": "Nome da Faixa 1 (O maior hit)",
                        "duration": 245
                    },
                    {
                        "id": "t1_2",
                        "rank": 2,
                        "title": "Nome da Faixa 2 (O segundo hit)",
                        "duration": 210
                    },
                    {
                        "id": "t1_3",
                        "rank": 3,
                        "title": "Nome da Faixa 3 (Deep cut)",
                        "duration": 305
                    }
                ]
            },
            {
                "id": "album_2",
                "artist": "Outro Artista",
                "title": "Outro √Ålbum",
                "year": 2022,
                "cover": "https://placehold.co/300x300/333/888?text=Capa",
                "tracks": [
                    {
                        "id": "t2_1",
                        "rank": 1,
                        "title": "Faixa Principal",
                        "duration": 190
                    }
                ]
            }
        ];

        // --- Fun√ß√µes Auxiliares ---

        /**
         * Formata segundos para o formato MM:SS
         */
        function formatDuration(seconds) {
            if (isNaN(seconds) || seconds < 0) return '00:00';
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        /**
         * Calcula a dura√ß√£o total de uma lista de faixas
         */
        function calculateTotalDuration(tracks) {
            if (!tracks || !Array.isArray(tracks)) return 0;
            return tracks.reduce((total, track) => total + (track.duration || 0), 0);
        }

        /**
         * Exibe o estado de "Salvando..." no bot√£o Salvar
         */
        function showSavingState() {
            saveBtn.classList.add('loading', 'bg-yellow-500', 'hover:bg-yellow-500');
            saveBtn.classList.remove('bg-spotify-green', 'hover:bg-green-400');
            saveText.textContent = 'Salvando...';
            saveIcon.innerHTML = `<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>`;
        }

        /**
         * Exibe o estado de "Salvo!" (Sucesso) no bot√£o Salvar
         */
        function showSavedState() {
            saveBtn.classList.remove('loading', 'bg-yellow-500', 'hover:bg-yellow-500');
            saveBtn.classList.add('bg-green-600', 'hover:bg-green-600');
            saveText.textContent = 'Salvo!';
            saveIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
            </svg>`;

            // Volta ao normal ap√≥s 1.5s
            setTimeout(resetSaveButton, 1500);
        }

        /**
         * Reseta o bot√£o Salvar para o estado padr√£o
         */
        function resetSaveButton() {
            saveBtn.classList.remove('loading', 'bg-yellow-500', 'hover:bg-yellow-500', 'bg-green-600', 'hover:bg-green-600');
            saveBtn.classList.add('bg-spotify-green', 'hover:bg-green-400');
            saveText.textContent = 'Salvar';
            saveIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
            </svg>`;
        }

        /**
         * Exibe mensagem de erro no bot√£o Salvar
         */
        function showSaveError(error) {
            console.error("Erro ao salvar:", error);
            saveBtn.classList.remove('loading', 'bg-yellow-500', 'bg-spotify-green');
            saveBtn.classList.add('bg-red-600', 'hover:bg-red-600');
            saveText.textContent = 'Erro!';
            saveIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>`;

            // Volta ao normal ap√≥s 2s
            setTimeout(resetSaveButton, 2000);
        }

        // --- Fun√ß√µes do Modal de Input (Passos 1-6) ---

        /**
         * (Passo 2) Abre o modal de carregamento de dados
         */
        function openDataModal() {
            // (Passo 6) Modificado: Se tivermos √°lbuns, mostre-os. Sen√£o, mostre o template.
            if (currentAlbums && currentAlbums.length > 0) {
                jsonInput.value = JSON.stringify(currentAlbums, null, 2);
            } else {
                jsonInput.value = JSON.stringify(jsonTemplate, null, 2);
            }
            jsonError.textContent = '';
            dataModal.classList.remove('hidden');
        }

        /**
         * (Passo 2) Fecha o modal de carregamento de dados
         */
        function closeDataModal() {
            dataModal.classList.add('hidden');
        }

        /**
         * (Passo 3) Processa o JSON e salva no Firestore
         */
        async function processAndSaveJSON() {
            let newData;
            try {
                newData = JSON.parse(jsonInput.value);
                if (!Array.isArray(newData)) {
                    throw new Error("O JSON deve ser um Array (lista) de √°lbuns.");
                }

                // Limpa erro, se houver
                jsonError.textContent = '';

                // Salva os novos dados (sobrescrevendo os antigos)
                await saveDataToFirestore(newData, currentPlaylists); // Salva os novos √°lbuns

                closeDataModal();

                // O listener (onSnapshot) vai pegar a mudan√ßa e re-renderizar a UI.

            } catch (error) {
                console.error("Erro no JSON:", error);
                jsonError.textContent = `Erro ao processar JSON: ${error.message}`;
            }
        }


        // --- Fun√ß√µes de Renderiza√ß√£o (UI) ---

        /**
         * Renderiza a View de √Ålbuns
         */
        function renderAlbumsView(albums) {
            // Limpa o grid
            albumsGrid.innerHTML = '';

            // Se n√£o houver √°lbuns, mostre uma mensagem
            if (!albums || albums.length === 0) {
                albumsGrid.innerHTML = `<p class="text-spotify-lightgray col-span-full text-center">Nenhum √°lbum carregado. Clique em "Carregar Dados" para come√ßar.</p>`;
                albumsSummary.innerHTML = `<p class="text-center text-spotify-lightgray">Nenhum dado de origem.</p>`;
                return;
            }

            let totalTracks = 0;
            let totalDuration = 0;

            albums.forEach(album => {
                if (!album) return; // Prote√ß√£o contra dados inv√°lidos

                const albumTracks = album.tracks || [];
                const albumDuration = calculateTotalDuration(albumTracks);
                totalTracks += albumTracks.length;
                totalDuration += albumDuration;

                const albumCard = document.createElement('div');
                albumCard.className = 'bg-spotify-lightdark p-4 rounded-lg shadow-lg flex flex-col transition-shadow hover:shadow-xl';
                albumCard.innerHTML = `
                    <div class="flex items-center mb-4">
                        <img src="${album.cover || 'https://placehold.co/100x100/333/888?text=Capa'}" alt="Capa do ${album.title}" class="w-20 h-20 rounded-md mr-4 object-cover" onerror="this.src='https://placehold.co/100x100/333/888?text=Capa'">
                        <div>
                            <h3 class="text-xl font-bold text-white">${album.title || 'T√≠tulo Desconhecido'}</h3>
                            <p class="text-sm text-spotify-lightgray">${album.artist || 'Artista Desconhecido'} (${album.year || '----'})</p>
                        </div>
                    </div>
                    <div class="border-t border-spotify-gray pt-2">
                        <div class="flex justify-between text-sm text-spotify-lightgray mb-2 px-2">
                            <span class="font-semibold">#</span>
                            <span class="flex-1 ml-4 font-semibold">Faixa</span>
                            <span class="font-semibold">Dura√ß√£o</span>
                        </div>
                        <ul class="space-y-1">
                            ${albumTracks
                        .sort((a, b) => (a.rank || 99) - (b.rank || 99)) // Ordena por rank
                        .map(track => `
                                <li class="flex justify-between items-center p-2 rounded-md hover:bg-spotify-gray">
                                    <span class="text-spotify-lightgray w-6 text-center">${track.rank || '-'}</span>
                                    <span class="flex-1 ml-2 text-white truncate" title="${track.title}">${track.title || 'Faixa Desconhecida'}</span>
                                    <span class="text-spotify-lightgray text-sm">${formatDuration(track.duration)}</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                    <div class="border-t border-spotify-gray mt-2 pt-2 text-right">
                        <span class="text-sm font-semibold text-spotify-lightgray">Total: ${albumTracks.length} faixas, ${formatDuration(albumDuration)}</span>
                    </div>
                `;
                albumsGrid.appendChild(albumCard);
            });

            // Renderiza o Resumo dos √Ålbuns
            albumsSummary.innerHTML = `
                <h3 class="text-lg font-semibold text-white mb-2">Resumo dos √Ålbuns (Origem)</h3>
                <div class="grid grid-cols-3 gap-4 text-center">
                    <div>
                        <p class="text-sm text-spotify-lightgray">Total de √Ålbuns:</p>
                        <p class="text-2xl font-bold text-white">${albums.length}</p>
                    </div>
                    <div>
                        <p class="text-sm text-spotify-lightgray">Total de Faixas:</p>
                        <p class="text-2xl font-bold text-white">${totalTracks}</p>
                    </div>
                    <div>
                        <p class="text-sm text-spotify-lightgray">Dura√ß√£o Total:</p>
                        <p class="text-2xl font-bold text-white">${formatDuration(totalDuration)}</p>
                    </div>
                </div>
            `;
        }

        /**
         * Renderiza a View de Playlists
         */
        function renderPlaylistsView(playlists) {
            // Limpa o grid
            playlistsGrid.innerHTML = '';

            // Destr√≥i inst√¢ncias antigas do Sortable para evitar memory leaks
            sortableInstances.forEach(s => s.destroy());
            sortableInstances = [];

            if (!playlists || playlists.length === 0) {
                playlistsGrid.innerHTML = `<p class="text-spotify-lightgray col-span-full text-center">Nenhuma playlist gerada. Volte e clique em "Gerar Playlists".</p>`;
                playlistsSummary.innerHTML = `<p class="text-center text-spotify-lightgray">Nenhuma playlist para resumir.</p>`;
                return;
            }

            let totalTracks = 0;
            let totalDuration = 0;

            playlists.forEach(playlist => {
                if (!playlist) return; // Prote√ß√£o

                const playlistTracks = playlist.tracks || [];
                const playlistDuration = calculateTotalDuration(playlistTracks);
                totalTracks += playlistTracks.length;
                totalDuration += playlistDuration;

                const playlistCard = document.createElement('div');
                playlistCard.className = 'bg-spotify-lightdark p-4 rounded-lg shadow-lg flex flex-col';
                playlistCard.innerHTML = `
                    <div class="mb-4">
                        <h3 class="text-xl font-bold text-white">${playlist.title || 'Playlist Sem T√≠tulo'}</h3>
                        <p class="text-sm text-spotify-lightgray">${playlist.subtitle || ' '}</p>
                    </div>
                    <div class="border-t border-spotify-gray pt-2 flex-1">
                        <div class="flex justify-between text-sm text-spotify-lightgray mb-2 px-2">
                            <span class="flex-1 font-semibold">Faixa (Rank)</span>
                            <span class="font-semibold">√Ålbum</span>
                            <span class="font-semibold">Dura√ß√£o</span>
                        </div>
                        <!-- Lista de faixas (container para SortableJS) -->
                        <ul id="playlist-${playlist.id}" data-playlist-id="${playlist.id}" class="space-y-1 h-full min-h-[150px]">
                            ${playlistTracks.map(track => renderTrackItem(track)).join('')}
                        </ul>
                    </div>
                    <div class="border-t border-spotify-gray mt-2 pt-2 text-right">
                        <span class="text-sm font-semibold text-spotify-lightgray">Total: ${playlistTracks.length} faixas, ${formatDuration(playlistDuration)}</span>
                    </div>
                `;
                playlistsGrid.appendChild(playlistCard);
            });

            // Renderiza o Resumo das Playlists
            renderPlaylistsSummary(playlists, totalTracks, totalDuration);

            // Inicializa o Drag-and-Drop (SortableJS)
            initSortable();
        }

        /**
         * Helper para renderizar um item de faixa (usado no Sortable)
         */
        function renderTrackItem(track) {
            // Encontra o √°lbum original da faixa
            const originAlbum = currentAlbums.find(a => a.tracks.some(t => t.id === track.id));
            const albumTitle = originAlbum ? originAlbum.title : 'N/A';

            return `
                <li class="track-item flex justify-between items-center p-2 rounded-md hover:bg-spotify-gray" data-track-id="${track.id}">
                    <div class="flex-1 truncate mr-2">
                        <p class="text-white truncate" title="${track.title}">${track.title || 'Faixa Desconhecida'}</p>
                        <p class="text-xs text-spotify-lightgray">Rank: ${track.rank || '-'}</p>
                    </div>
                    <span class="text-spotify-lightgray text-sm w-16 truncate text-center" title="${albumTitle}">${albumTitle}</span>
                    <span class="text-spotify-lightgray text-sm w-12 text-right">${formatDuration(track.duration)}</span>
                </li>
            `;
        }

        /**
         * Renderiza o Resumo de Verifica√ß√£o das Playlists
         */
        function renderPlaylistsSummary(playlists, totalTracks, totalDuration) {
            // Calcula os totais de origem (dos √°lbuns)
            let originTotalTracks = 0;
            let originTotalDuration = 0;
            if (currentAlbums && currentAlbums.length > 0) {
                currentAlbums.forEach(album => {
                    if (album && album.tracks) {
                        originTotalTracks += album.tracks.length;
                        originTotalDuration += calculateTotalDuration(album.tracks);
                    }
                });
            }

            // Verifica se os totais batem
            const tracksMatch = originTotalTracks === totalTracks;
            const durationMatch = originTotalDuration === totalDuration;
            const isOk = tracksMatch && durationMatch;

            let verificationHtml = '';
            if (isOk) {
                verificationHtml = `<p class="text-2xl font-bold text-green-400">OK - Totais Batem!</p>`;
            } else {
                verificationHtml = `
                    <p class="text-2xl font-bold text-red-400">ERRO - Totais Divergentes!</p>
                    <div class="flex justify-around mt-2 text-sm">
                        <p class="text-gray-300">Origem: <span class="font-bold">${originTotalTracks} faixas</span> / <span class="font-bold">${formatDuration(originTotalDuration)}</span></p>
                        <p class="text-gray-300">Resultado: <span class="font-bold">${totalTracks} faixas</span> / <span class="font-bold">${formatDuration(totalDuration)}</span></p>
                    </div>
                `;
            }

            playlistsSummary.innerHTML = `
                <h3 class="text-lg font-semibold text-white mb-2">Resumo das Playlists (Resultado)</h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center mb-4">
                    <div>
                        <p class="text-sm text-spotify-lightgray">Total de Playlists:</p>
                        <p class="text-2xl font-bold text-white">${playlists.length}</p>
                    </div>
                    <div>
                        <p class="text-sm text-spotify-lightgray">Total de Faixas:</p>
                        <p class="text-2xl font-bold text-white">${totalTracks}</p>
                    </div>
                    <div>
                        <p class="text-sm text-spotify-lightgray">Dura√ß√£o Total:</p>
                        <p class="text-2xl font-bold text-white">${formatDuration(totalDuration)}</p>
                    </div>
                </div>
                <div class="border-t border-spotify-gray pt-4 text-center">
                    <h4 class="text-md font-semibold text-white mb-1">Verifica√ß√£o de Integridade</h4>
                    ${verificationHtml}
                </div>
            `;
        }

        /**
         * Atualiza a UI (√Ålbuns ou Playlists)
         */
        function toggleView() {
            isAlbumsView = !isAlbumsView;
            if (isAlbumsView) {
                albumsView.classList.remove('hidden');
                playlistsView.classList.add('hidden');
                toggleViewBtn.textContent = 'Ver Playlists';
            } else {
                albumsView.classList.add('hidden');
                playlistsView.classList.remove('hidden');
                toggleViewBtn.textContent = 'Ver √Ålbuns';
                // Re-renderiza as playlists para garantir que o D&D funcione
                renderPlaylistsView(currentPlaylists);
            }
        }

        // --- Drag-and-Drop (SortableJS) ---

        /**
         * Inicializa o SortableJS em todas as listas de playlists
         */
        function initSortable() {
            const lists = document.querySelectorAll('#playlists-grid ul');
            lists.forEach(list => {
                // 'playlists' √© o 'group name'. Isso permite arrastar entre listas.
                const sortable = new window.Sortable(list, {
                    group: 'playlists',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    dragClass: 'sortable-drag',
                    onEnd: handleDragEnd // Fun√ß√£o chamada ao soltar
                });
                sortableInstances.push(sortable);
            });
        }

        /**
         * Chamada quando o usu√°rio solta uma faixa
         */
        function handleDragEnd(evt) {
            const trackId = evt.item.dataset.trackId;
            const fromListId = evt.from.dataset.playlistId;
            const toListId = evt.to.dataset.playlistId;

            // Se moveu para a mesma lista, apenas a ordem mudou
            if (fromListId === toListId) {
                updateTrackOrder(toListId, evt.newIndex, trackId);
            } else {
                // Moveu entre listas
                moveTrackBetweenPlaylists(fromListId, toListId, evt.oldIndex, evt.newIndex, trackId);
            }

            // O estado mudou, habilita o bot√£o Salvar
            resetSaveButton();
        }

        /**
         * Atualiza o estado (currentPlaylists) ap√≥s mover faixa na *mesma* lista
         */
        function updateTrackOrder(playlistId, newIndex, trackId) {
            const playlist = currentPlaylists.find(p => p.id === playlistId);
            if (!playlist) return;

            // Encontra e remove a faixa
            const track = playlist.tracks.find(t => t.id === trackId);
            playlist.tracks = playlist.tracks.filter(t => t.id !== trackId);

            // Re-insere na nova posi√ß√£o
            if (track) {
                playlist.tracks.splice(newIndex, 0, track);
            }

            // Re-renderiza APENAS as playlists para recalcular dura√ß√µes
            renderPlaylistsView(currentPlaylists);
        }

        /**
         * Atualiza o estado (currentPlaylists) ap√≥s mover faixa *entre* listas
         */
        function moveTrackBetweenPlaylists(fromListId, toListId, oldIndex, newIndex, trackId) {
            const fromPlaylist = currentPlaylists.find(p => p.id === fromListId);
            const toPlaylist = currentPlaylists.find(p => p.id === toListId);
            if (!fromPlaylist || !toPlaylist) return;

            // Encontra e remove da lista antiga
            let trackToMove = null;
            // √â mais seguro achar pelo ID do que pelo √≠ndice
            const trackIndex = fromPlaylist.tracks.findIndex(t => t.id === trackId);
            if (trackIndex > -1) {
                trackToMove = fromPlaylist.tracks.splice(trackIndex, 1)[0];
            }

            // Adiciona na nova lista, na posi√ß√£o correta
            if (trackToMove) {
                toPlaylist.tracks.splice(newIndex, 0, trackToMove);
            }

            // Re-renderiza TUDO para atualizar dura√ß√µes e totais
            renderPlaylistsView(currentPlaylists);
        }


        // --- L√≥gica do Algoritmo de Curadoria ---

        /**
         * Ponto de entrada principal do algoritmo
         */
        function runHybridCuration() {
            if (!currentAlbums || currentAlbums.length === 0) {
                alert("Nenhum √°lbum carregado para processar.");
                return;
            }

            // Deep clone dos √°lbuns para n√£o modificar os dados originais
            let workingAlbums = JSON.parse(JSON.stringify(currentAlbums));

            // --- FASE 1: Prepara√ß√£o ---
            const P_HITS = 2; // P1 (Hits 1) e P2 (Hits 2)

            // Inicializa as playlists
            let newPlaylists = [
                { id: 'p1', title: 'Greatest Hits Vol. 1', subtitle: 'Rank #1 de cada √°lbum', tracks: [] },
                { id: 'p2', title: 'Greatest Hits Vol. 2', subtitle: 'Rank #2 de cada √°lbum', tracks: [] }
            ];

            // --- FASE 2: Extra√ß√£o dos "Greatest Hits" ---
            let remainingTracksPool = [];

            workingAlbums.forEach(album => {
                if (!album || !album.tracks) return; // Prote√ß√£o

                let tracks = [...album.tracks]; // Copia as faixas

                // Move Faixa #1 para P1
                let track1 = tracks.find(t => t.rank === 1);
                if (track1) {
                    newPlaylists[0].tracks.push(track1);
                    tracks = tracks.filter(t => t.id !== track1.id);
                }

                // Move Faixa #2 para P2
                let track2 = tracks.find(t => t.rank === 2);
                if (track2) {
                    newPlaylists[1].tracks.push(track2);
                    tracks = tracks.filter(t => t.id !== track2.id);
                }

                // Adiciona o restante ao "pool" de Deep Cuts
                // Guarda a refer√™ncia do √°lbum para a "Rule of Thumb #2"
                tracks.forEach(t => {
                    t.originAlbumId = album.id;
                    remainingTracksPool.push(t);
                });
            });

            // Ordena o "pool" por aclama√ß√£o (Rank)
            remainingTracksPool.sort((a, b) => a.rank - b.rank);


            // --- PR√â-FASE 3: C√°lculo do P-Ideal (Baseado na Dura√ß√£o) ---
            const DURATION_TARGET_S = 45 * 60; // 45 min
            const totalDeepCutsDuration = calculateTotalDuration(remainingTracksPool);

            // (Corre√ß√£o do Passo 6: Usar Math.ceil)
            // Se tivermos 2.1x de dura√ß√£o, precisamos de 3 playlists.
            const P_DEEP_CUTS_IDEAL = Math.ceil(totalDeepCutsDuration / DURATION_TARGET_S);

            // Se P_DEEP_CUTS_IDEAL for 0 (nenhuma faixa restante), defina como 1 para evitar divis√£o por zero
            const numDeepCutPlaylists = Math.max(1, P_DEEP_CUTS_IDEAL);

            // Cria as playlists de Deep Cuts
            for (let i = 0; i < numDeepCutPlaylists; i++) {
                newPlaylists.push({
                    id: `p${P_HITS + i + 1}`,
                    title: `Deep Cuts Vol. ${i + 1}`,
                    subtitle: 'S-Draft Balanceado',
                    tracks: []
                });
            }

            // --- FASE 3: Distribui√ß√£o S-Draft (Serpentine) Otimizada ---
            // O S-Draft agora opera no "pool" de faixas, n√£o por √°lbum

            let direction = 1; // 1 = para frente, -1 = para tr√°s
            let p_index = 0; // √çndice da playlist de deep cuts (0 a numDeepCutPlaylists-1)

            remainingTracksPool.forEach(track => {
                // O √≠ndice na lista 'newPlaylists' √© (p_index + P_HITS)
                newPlaylists[p_index + P_HITS].tracks.push(track);

                // L√≥gica Serpentine
                p_index += direction;

                // "Quicar" (Bounce) nos extremos
                if (p_index >= numDeepCutPlaylists) {
                    direction = -1;
                    p_index = numDeepCutPlaylists - 1; // Corrige o √≠ndice
                } else if (p_index < 0) {
                    direction = 1;
                    p_index = 0; // Corrige o √≠ndice
                }
            });

            // --- FASE 4: Rebalanceamento Autom√°tico (Ajuste Fino) ---
            // Esta fun√ß√£o tentar√° fazer "trocas" (swaps) para otimizar a dura√ß√£o,
            // respeitando o Rule of Thumb #2 (representa√ß√£o de √°lbuns).
            newPlaylists = runFase4SwapBalancing(newPlaylists, DURATION_TARGET_S);

            // Atualiza o estado global e salva
            currentPlaylists = newPlaylists;
            saveDataToFirestore(currentAlbums, newPlaylists);

            // Muda para a view de playlists
            if (isAlbumsView) {
                toggleView();
            } else {
                // Se j√° estiver na view, re-renderiza
                renderPlaylistsView(currentPlaylists);
            }
        }

        /**
         * FASE 4: Algoritmo de Otimiza√ß√£o de Dura√ß√£o (Swaps)
         */
        function runFase4SwapBalancing(playlists, targetDurationS) {
            const FLEXIBILITY = 7 * 60; // 7 min
            const MAX_SWAP_ITERATIONS = 100; // Limite de tentativas

            for (let iter = 0; iter < MAX_SWAP_ITERATIONS; iter++) {
                // 1. Calcula dura√ß√µes atuais
                let p_durations = playlists.map(p => ({
                    id: p.id,
                    duration: calculateTotalDuration(p.tracks),
                    playlist: p
                }));

                // 2. Encontra a mais longa (over) e a mais curta (under)
                p_durations.sort((a, b) => a.duration - b.duration);
                let p_under = p_durations[0];
                let p_over = p_durations[p_durations.length - 1];

                // 3. Verifica se est√£o dentro da flexibilidade
                const isUnderOk = p_under.duration >= (targetDurationS - FLEXIBILITY);
                const isOverOk = p_over.duration <= (targetDurationS + FLEXIBILITY);

                if (isUnderOk && isOverOk) {
                    // Todas as playlists est√£o balanceadas. Fim.
                    console.log(`Balanceamento conclu√≠do na itera√ß√£o ${iter}.`);
                    return playlists;
                }

                // 4. Se n√£o estiverem balanceadas, encontrar a "melhor troca" (1-por-1)

                let bestSwap = {
                    trackOver: null, // Faixa saindo da 'over'
                    trackUnder: null, // Faixa saindo da 'under'
                    newGap: Math.abs(p_over.duration - p_under.duration) // Gap atual
                };

                for (const trackOver of p_over.playlist.tracks) {
                    for (const trackUnder of p_under.playlist.tracks) {

                        // --- Valida√ß√£o do Rule of Thumb #2 (Representa√ß√£o de √Ålbuns) ---
                        // A troca √© v√°lida?
                        if (!isSwapValid(p_over.playlist, p_under.playlist, trackOver, trackUnder)) {
                            continue; // Pula esta troca, ela quebra a regra.
                        }
                        // ----------------------------------------------------------------

                        // Calcula o novo gap se fizermos esta troca
                        const newOverDuration = p_over.duration - trackOver.duration + trackUnder.duration;
                        const newUnderDuration = p_under.duration - trackUnder.duration + trackOver.duration;
                        const newGap = Math.abs(newOverDuration - newUnderDuration);

                        // Se esta troca for melhor (reduz o gap), salve-a
                        if (newGap < bestSwap.newGap) {
                            bestSwap = { trackOver, trackUnder, newGap };
                        }
                    }
                }

                // 5. Executar a melhor troca encontrada
                if (bestSwap.trackOver) {
                    // Executa a troca (swap)

                    // Remove trackOver de p_over e adiciona trackUnder
                    p_over.playlist.tracks = p_over.playlist.tracks.filter(t => t.id !== bestSwap.trackOver.id);
                    p_over.playlist.tracks.push(bestSwap.trackUnder);

                    // Remove trackUnder de p_under e adiciona trackOver
                    p_under.playlist.tracks = p_under.playlist.tracks.filter(t => t.id !== bestSwap.trackUnder.id);
                    p_under.playlist.tracks.push(bestSwap.trackOver);

                } else {
                    // Nenhuma troca v√°lida foi encontrada que melhore o gap.
                    console.log(`Balanceamento parado na itera√ß√£o ${iter}: nenhuma troca v√°lida encontrada.`);
                    return playlists; // Para o loop
                }
            }

            console.log(`Balanceamento parado: Atingiu ${MAX_SWAP_ITERATIONS} itera√ß√µes.`);
            return playlists; // Retorna o melhor que conseguiu
        }

        /**
         * Verifica se uma troca (swap) viola o Rule of Thumb #2
         */
        function isSwapValid(p_over, p_under, trackOver, trackUnder) {
            // (trackOver est√° saindo de p_over, trackUnder est√° saindo de p_under)

            // Pergunta 1: trackOver √© a √∫ltima representante do seu √°lbum em p_over?
            // E (AND) trackUnder (que est√° entrando) N√ÉO √© desse mesmo √°lbum?
            const isLast_Over = isLastTrackOfAlbumInPlaylist(p_over, trackOver);
            if (isLast_Over && (trackOver.originAlbumId !== trackUnder.originAlbumId)) {
                return false; // Inv√°lido. Quebra a regra em p_over.
            }

            // Pergunta 2: trackUnder √© a √∫ltima representante do seu √°lbum em p_under?
            // E (AND) trackOver (que est√° entrando) N√ÉO √© desse mesmo √°lbum?
            const isLast_Under = isLastTrackOfAlbumInPlaylist(p_under, trackUnder);
            if (isLast_Under && (trackUnder.originAlbumId !== trackOver.originAlbumId)) {
                return false; // Inv√°lido. Quebra a regra em p_under.
            }

            // Se passou nas duas checagens, a troca √© v√°lida.
            return true;
        }

        /**
         * Helper que verifica se uma faixa √© a √∫ltima do seu √°lbum em uma playlist
         */
        function isLastTrackOfAlbumInPlaylist(playlist, track) {
            if (!track.originAlbumId) return false; // Faixas de Hits (P1, P2) podem n√£o ter isso

            let count = 0;
            for (const t of playlist.tracks) {
                if (t.originAlbumId === track.originAlbumId) {
                    count++;
                }
            }
            return count === 1;
        }


        // --- Fun√ß√µes de Dados (Firestore) ---

        /**
         * Salva os dados (ambos √°lbuns e playlists) no Firestore
         */
        async function saveDataToFirestore(albums, playlists) {
            if (!userId) {
                console.error("Usu√°rio n√£o autenticado. N√£o √© poss√≠vel salvar.");
                return;
            }

            showSavingState();

            try {
                // Prepara os dados para salvar (converte para JSON puro)
                const albumsData = { data: JSON.parse(JSON.stringify(albums)) };
                const playlistsData = { data: JSON.parse(JSON.stringify(playlists)) };

                // Salva ambos
                await setDoc(albumsDocRef, albumsData);
                await setDoc(playlistsDocRef, playlistsData);

                showSavedState();

            } catch (error) {
                showSaveError(error);
            }
        }

        /**
         * Carrega os dados (√Ålbuns e Playlists) do Firestore
         */
        function loadData() {
            if (!userId) {
                console.error("Usu√°rio n√£o autenticado. N√£o √© poss√≠vel carregar.");
                return;
            }

            // Define os caminhos dos documentos
            albumsDocRef = doc(db, `artifacts/${appId}/users/${userId}/curator/albums`);
            playlistsDocRef = doc(db, `artifacts/${appId}/users/${userId}/curator/playlists`);

            // Listener para √ÅLBUNS
            if (unsubscribeAlbums) unsubscribeAlbums(); // Remove listener antigo
            unsubscribeAlbums = onSnapshot(albumsDocRef, (docSnap) => {
                loadingSpinner.classList.add('hidden'); // Esconde o spinner

                if (docSnap.exists()) {
                    currentAlbums = docSnap.data().data || [];
                    console.log("√Ålbuns carregados:", currentAlbums.length);
                    // (Passo 4) N√£o abrimos o modal se os dados existem

                } else {
                    // (Passo 4) Modificado: N√£o existem dados. For√ßa o modal.
                    console.log("Nenhum √°lbum encontrado. Abrindo modal de input.");
                    currentAlbums = [];
                    openDataModal(); // For√ßa o usu√°rio a carregar dados
                }

                // Re-renderiza a view de √°lbuns
                renderAlbumsView(currentAlbums);

            }, (error) => {
                console.error("Erro ao carregar √°lbuns:", error);
                alert("Erro ao carregar dados dos √°lbuns.");
            });

            // Listener para PLAYLISTS
            if (unsubscribePlaylists) unsubscribePlaylists(); // Remove listener antigo
            unsubscribePlaylists = onSnapshot(playlistsDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    currentPlaylists = docSnap.data().data || [];
                    console.log("Playlists carregadas:", currentPlaylists.length);
                } else {
                    console.log("Nenhum documento de playlists encontrado.");
                    currentPlaylists = [];
                }

                // Re-renderiza a view de playlists (se ela estiver ativa)
                if (!isAlbumsView) {
                    renderPlaylistsView(currentPlaylists);
                }

            }, (error) => {
                console.error("Erro ao carregar playlists:", error);
                alert("Erro ao carregar dados das playlists.");
            });
        }

        // --- Inicializa√ß√£o da Aplica√ß√£o ---

        /**
         * Ponto de entrada principal
         */
        async function initializeAppContainer() {
            // Habilita logs do Firestore
            setLogLevel('Debug');

            // Inicializa Firebase
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch (error) {
                console.error("Erro ao inicializar Firebase:", error);
                mainContent.innerHTML = `<p class="text-red-400 text-center">Erro cr√≠tico ao conectar com o Firebase. Verifique a configura√ß√£o.</p>`;
                loadingSpinner.classList.add('hidden');
                return;
            }

            // Busca os elementos da UI (ap√≥s o DOM estar pronto)
            mainContent = document.getElementById('main-content');
            loadingSpinner = document.getElementById('loading-spinner');
            albumsView = document.getElementById('albums-view');
            playlistsView = document.getElementById('playlists-view');
            albumsGrid = document.getElementById('albums-grid');
            playlistsGrid = document.getElementById('playlists-grid');
            toggleViewBtn = document.getElementById('toggleViewBtn');
            generateBtn = document.getElementById('generateBtn');
            saveBtn = document.getElementById('saveBtn');
            saveText = document.getElementById('save-text');
            saveIcon = document.getElementById('save-icon');
            albumsSummary = document.getElementById('albums-summary');
            playlistsSummary = document.getElementById('playlists-summary');

            // Busca Elementos do Modal (Passos 1-3)
            loadDataBtn = document.getElementById('loadDataBtn');
            dataModal = document.getElementById('dataModal');
            closeModalBtn = document.getElementById('closeModalBtn');
            cancelModalBtn = document.getElementById('cancelModalBtn');
            processJsonBtn = document.getElementById('processJsonBtn');
            jsonInput = document.getElementById('jsonInput');
            jsonError = document.getElementById('jsonError');

            // Adiciona Listeners de Eventos
            toggleViewBtn.addEventListener('click', toggleView);
            generateBtn.addEventListener('click', runHybridCuration);
            saveBtn.addEventListener('click', () => saveDataToFirestore(currentAlbums, currentPlaylists));

            // Listeners do Modal (Passos 2-3)
            loadDataBtn.addEventListener('click', openDataModal);
            closeModalBtn.addEventListener('click', closeDataModal);
            cancelModalBtn.addEventListener('click', closeDataModal);
            processJsonBtn.addEventListener('click', processAndSaveJSON);

            // Autentica o usu√°rio (An√¥nimo ou com Token)
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Erro na autentica√ß√£o:", error);
                loadingSpinner.classList.add('hidden');
                mainContent.innerHTML = `<p class="text-red-400 text-center">Erro de autentica√ß√£o. O app n√£o pode carregar.</p>`;
                return;
            }

            // Listener de mudan√ßa de autentica√ß√£o
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    console.log("Usu√°rio autenticado:", user.uid);
                    userId = user.uid;

                    // Mostra a view de √°lbuns (default)
                    albumsView.classList.remove('hidden');

                    // Carrega os dados do Firestore
                    loadData();

                } else {
                    console.log("Usu√°rio deslogado.");
                    userId = null;
                    if (unsubscribeAlbums) unsubscribeAlbums();
                    if (unsubscribePlaylists) unsubscribePlaylists();
                }
            });
        }

        /**
         * Inicializador Robusto
         * Espera ativamente pelo SortableJS e pelo DOM.
         */
        function robustInit() {
            let attempts = 0;
            const maxAttempts = 100; // 10 segundos

            const interval = setInterval(() => {
                attempts++;

                // Tenta inicializar
                if (typeof window.Sortable !== 'undefined') {
                    clearInterval(interval);
                    console.log("Sortable.js carregado. Inicializando app.");
                    initializeAppContainer();
                }
                // Falha
                else if (attempts > maxAttempts) {
                    clearInterval(interval);
                    console.error("ERRO CR√çTICO: Sortable.js falhou ao carregar ap√≥s 10 segundos.");
                    loadingSpinner.classList.add('hidden');
                    mainContent.innerHTML = `<p class="text-red-400 text-center">Erro cr√≠tico: A biblioteca de Drag-and-Drop (Sortable.js) falhou ao carregar. Tente recarregar a p√°gina.</p>`;
                }
            }, 100); // Verifica a cada 100ms
        }

        // --- Ponto de Entrada ---
        // Espera o DOM estar pronto E o SortableJS estar carregado
        document.addEventListener('DOMContentLoaded', () => {
            robustInit();
        });

    </script>

</body>

</html>