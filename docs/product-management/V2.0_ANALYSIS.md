# AnÃ¡lise do Plano MJRP Playlist Generator 2.0

## Resumo Executivo

O plano v2.0 propÃµe uma evoluÃ§Ã£o significativa da aplicaÃ§Ã£o atual (v1.6.1) de uma ferramenta single-page para um **SPA multi-seÃ§Ã£o com gestÃ£o de sÃ©ries de playlists**. A proposta Ã© tecnicamente sÃ³lida e bem estruturada, mas requer atenÃ§Ã£o especial a alguns pontos crÃ­ticos.

### Estado Atual (v1.6.1) âœ…
- âœ… Arquitetura modular (shared/normalize.js, CurationEngine)
- âœ… Backend funcionando em produÃ§Ã£o (Cloud Run)
- âœ… Scraping BestEverAlbums com ratings
- âœ… ConsolidaÃ§Ã£o de rankings funcional
- âœ… Deploy automatizado (scripts/deploy-backend.sh, scripts/deploy-prod.sh)

### Proposta v2.0 ğŸ¯
Transformar em SPA com:
1. **NavegaÃ§Ã£o por seÃ§Ãµes** (Home, Ãlbuns, Ranking, Playlists)
2. **PersistÃªncia Firestore** (sÃ©ries, histÃ³rico, versionamento)
3. **Bundler moderno** (Vite/Rollup)
4. **Testes headless** (Vitest + jsdom)
5. **ComponentizaÃ§Ã£o** (stores, views, components)

---

## AnÃ¡lise por Fase

### 0ï¸âƒ£ PrÃ©-requisitos (Refactor 1.5)
**Status**: âœ… **Praticamente completo**

| Item | Status | Notas |
|------|--------|-------|
| `shared/normalize.js` consolidado | âœ… Feito | Funcionando em prod (v1.6.1) |
| `buildTracksForCurationInput` modular | âš ï¸ Parcial | Existe em `CurationEngine`, mas nÃ£o em mÃ³dulo standalone |
| Telemetria frontend | âŒ Pendente | Logs de fallback nÃ£o implementados |
| Testes headless para "acclaim order" | âŒ Pendente | Nenhum teste de UI atualmente |

**RecomendaÃ§Ãµes**:
- âœ… Pode prosseguir para Fase 1 (os itens pendentes nÃ£o sÃ£o blockers crÃ­ticos)
- âš ï¸ Priorizar telemetria antes da migraÃ§Ã£o Firestore (serÃ¡ Ãºtil para debugging)

---

### 1ï¸âƒ£ FundaÃ§Ã£o TÃ©cnica

#### 1.1 ModularizaÃ§Ã£o em Stores
**Proposta**: Separar `app.js` em `stores/albums.js` e `stores/playlists.js`

**AvaliaÃ§Ã£o**: âœ… **Excelente ideia**

**BenefÃ­cios**:
- Estado centralizado e previsÃ­vel
- Facilita testes unitÃ¡rios
- Reduz acoplamento entre UI e lÃ³gica

**Arquitetura sugerida**:
```
public/js/
â”œâ”€â”€ stores/
â”‚   â”œâ”€â”€ albums.js       # Estado: currentAlbums, tracksByAlbum
â”‚   â”œâ”€â”€ playlists.js    # Estado: generatedPlaylists, playlistConfig
â”‚   â””â”€â”€ series.js       # Estado: activeSeries, seriesMetadata (novo)
â”œâ”€â”€ views/
â”‚   â”œâ”€â”€ home.js
â”‚   â”œâ”€â”€ albums.js
â”‚   â”œâ”€â”€ ranking.js
â”‚   â””â”€â”€ playlists.js
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ topNav.js
â”‚   â””â”€â”€ albumCard.js
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ normalize.js
â”‚   â””â”€â”€ tracks.js       # buildTracksForCurationInput
â””â”€â”€ app.js              # Orquestrador principal
```

**Risco**: ğŸŸ¡ **MÃ©dio**
- RefatoraÃ§Ã£o grande de `app.js` (~800 linhas)
- Requer testes de regressÃ£o extensivos

**MitigaÃ§Ã£o**:
- Criar branch `feature/v2.0-stores`
- Migrar incrementalmente (comeÃ§ar por `albums.js`)
- Manter `app.js` funcional durante transiÃ§Ã£o

#### 1.2 AdoÃ§Ã£o de Bundler (Vite/Rollup)
**Proposta**: Empacotar mÃ³dulos ES com Vite ou Rollup

**AvaliaÃ§Ã£o**: âœ… **Altamente recomendado**

**Vite vs Rollup**:

| CritÃ©rio | Vite | Rollup |
|----------|------|--------|
| Dev Server | âœ… HMR nativo | âŒ Requer config manual |
| Build Speed | âœ… Muito rÃ¡pido (esbuild) | ğŸŸ¡ Mais lento |
| Learning Curve | âœ… MÃ­nima | ğŸŸ¡ Moderada |
| Tree Shaking | âœ… Excelente | âœ… Excelente |
| Tamanho bundle | âœ… Otimizado | âœ… Otimizado |

**RecomendaÃ§Ã£o**: **Vite** (melhor DX, HMR, compatÃ­vel com Firebase Hosting)

**Setup Vite**:
```bash
npm install -D vite
```

```javascript
// vite.config.js
export default {
  build: {
    outDir: 'public/dist',
    rollupOptions: {
      input: {
        main: 'public/hybrid-curator.html'
      }
    }
  },
  server: {
    port: 5000
  }
}
```

**Risco**: ğŸŸ¢ **Baixo**
- MudanÃ§a nÃ£o-destrutiva (pode coexistir com setup atual)
- Firebase Hosting suporta servir bundles Vite

#### 1.3 SuÃ­te de Testes (Vitest + jsdom)
**Proposta**: Testes headless para UI, ordenaÃ§Ã£o, telemetria

**AvaliaÃ§Ã£o**: âœ… **CrÃ­tico para sucesso**

**Setup**:
```bash
npm install -D vitest jsdom @vitest/ui
```

```javascript
// vitest.config.js
export default {
  test: {
    environment: 'jsdom',
    coverage: {
      reporter: ['text', 'html']
    }
  }
}
```

**Casos de teste prioritÃ¡rios**:
1. `buildTracksForCurationInput` ordenaÃ§Ã£o (acclaim vs canonical)
2. `CurationEngine.generate()` P1/P2 selection
3. NormalizaÃ§Ã£o de tracks (`shared/normalize.js`)
4. Stores (mutations, getters)

**Risco**: ğŸŸ¡ **MÃ©dio**
- Requer mock de Firestore SDK
- DOM manipulation testing pode ser flaky

**MitigaÃ§Ã£o**:
- ComeÃ§ar com testes de lÃ³gica pura (sem DOM)
- Usar `@testing-library/dom` para queries robustas

---

### 2ï¸âƒ£ Arquitetura SPA / NavegaÃ§Ã£o

#### 2.1 Roteamento (HashRouter)
**Proposta**: Estados `home`, `albums`, `ranking`, `playlists`

**AvaliaÃ§Ã£o**: âœ… **Adequado para v2.0**

**ImplementaÃ§Ã£o sugerida**:
```javascript
// router.js
export class Router {
  constructor() {
    this.routes = {
      '#home': () => import('./views/home.js'),
      '#albums': () => import('./views/albums.js'),
      '#ranking': () => import('./views/ranking.js'),
      '#playlists': () => import('./views/playlists.js')
    }
    this.current = null
  }

  async navigate(hash) {
    const route = this.routes[hash || '#home']
    if (route) {
      const module = await route()
      this.current?.unmount?.()
      this.current = await module.default.mount()
    }
  }

  init() {
    window.addEventListener('hashchange', () => this.navigate(location.hash))
    this.navigate(location.hash || '#home')
  }
}
```

**Risco**: ğŸŸ¢ **Baixo**
- HashRouter funciona bem com Firebase Hosting (sem config de rewrites)
- Lazy loading nativo com `import()`

#### 2.2 ComponentizaÃ§Ã£o
**Proposta**: `views/`, `components/`, layout compartilhado

**AvaliaÃ§Ã£o**: âœ… **Estrutura limpa**

**Componente `topNav.js`**:
```javascript
export class TopNav {
  constructor(container) {
    this.container = container
  }

  render(activeRoute) {
    this.container.innerHTML = `
      <nav class="top-nav">
        <a href="#home" class="${activeRoute === 'home' ? 'active' : ''}">Home</a>
        <a href="#albums" class="${activeRoute === 'albums' ? 'active' : ''}">Ãlbuns</a>
        <a href="#ranking" class="${activeRoute === 'ranking' ? 'active' : ''}">Ranking</a>
        <a href="#playlists" class="${activeRoute === 'playlists' ? 'active' : ''}">Playlists</a>
      </nav>
    `
  }
}
```

**Risco**: ğŸŸ¡ **MÃ©dio**
- Requer consistÃªncia em lifecycle (mount, unmount, update)
- Sem framework, gerenciamento de estado pode ficar complexo

**MitigaÃ§Ã£o**:
- Definir interface clara para componentes
- Considerar micro-framework leve (Preact, Alpine.js) se complexidade crescer

---

### 3ï¸âƒ£ Home / Landing (1.0)

#### 3.1 FormulÃ¡rio de SÃ©ries
**Proposta**: Input de Ã¡lbuns + nome da sÃ©rie â†’ Firestore

**AvaliaÃ§Ã£o**: âœ… **Funcionalidade core bem definida**

**Schema Firestore**:
```javascript
// Collection: series
{
  id: "auto-generated",
  name: "Classic Rock Collection",
  albumQueries: [
    "Led Zeppelin - Physical Graffiti",
    "Pink Floyd - The Wall"
  ],
  createdAt: Timestamp,
  updatedAt: Timestamp,
  status: "pending" | "processing" | "complete",
  notes: "User notes"
}
```

**Fluxo**:
1. UsuÃ¡rio entra lista de Ã¡lbuns (textarea)
2. Click "Gerar ranking agora"
3. POST `/api/batch-generate` (novo endpoint)
4. Backend processa e salva em Firestore
5. Redirect para `#ranking?series={id}`

**Risco**: ğŸŸ¡ **MÃ©dio a Alto**
- Novo endpoint `/api/batch-generate` requer implementaÃ§Ã£o
- Processamento batch pode ser lento (mÃºltiplos scrapers)
- Rate limiting BestEverAlbums

**MitigaÃ§Ã£o**:
- Implementar queue (Cloud Tasks ou PubSub)
- Polling/WebSocket para status updates
- Exibir progresso ("2/5 Ã¡lbuns processados...")

#### 3.2 HistÃ³rico de SÃ©ries
**Proposta**: Listar sÃ©ries recentes com atalho para retomar

**AvaliaÃ§Ã£o**: âœ… **Melhora UX significativamente**

**Query Firestore**:
```javascript
const recentSeries = await db.collection('series')
  .orderBy('updatedAt', 'desc')
  .limit(5)
  .get()
```

**Risco**: ğŸŸ¢ **Baixo**
- Query simples, sem joins complexos

---

### 4ï¸âƒ£ Ver Ãlbuns Salvos (1.1)

#### 4.1 Listagem com Filtros
**Proposta**: Filtrar por artista, ano, status, presenÃ§a BestEver

**AvaliaÃ§Ã£o**: âœ… **Ãštil para grandes coleÃ§Ãµes**

**ImplementaÃ§Ã£o**:
```javascript
// Client-side filtering (para < 100 Ã¡lbuns)
const filtered = albums.filter(a => {
  return (
    (!filters.artist || a.artist.includes(filters.artist)) &&
    (!filters.year || a.year === filters.year) &&
    (!filters.status || a.status === filters.status) &&
    (!filters.hasBestEver || a.bestEverAlbumId)
  )
})
```

**Risco**: ğŸŸ¡ **MÃ©dio**
- Client-side filtering nÃ£o escala para 1000+ Ã¡lbuns
- Pode precisar de Firestore queries compostas no futuro

**MitigaÃ§Ã£o**:
- ComeÃ§ar com client-side para v2.0
- Monitorar performance, migrar para server-side se necessÃ¡rio

#### 4.2 AÃ§Ãµes RÃ¡pidas
**Proposta**: Remover, reprocessar, abrir referÃªncia BestEver

**AvaliaÃ§Ã£o**: âœ… **Features valiosas**

**"Reprocessar aclamaÃ§Ã£o"**:
- POST `/api/reprocess-album` â†’ atualiza cache Firestore
- Ãštil quando BestEverAlbums atualiza dados

**Risco**: ğŸŸ¢ **Baixo**
- Reutiliza lÃ³gica existente de `/api/generate`

---

### 5ï¸âƒ£ Ranking de AclamaÃ§Ã£o (1.2)

#### 5.1 PÃ¡gina de Ranking
**Proposta**: Tabs (Resumo, Fontes, Logs)

**AvaliaÃ§Ã£o**: âœ… **Excelente observabilidade**

**Tab "Logs" (Telemetria)**:
```javascript
// Adicionar a fetchRanking.js
debugTrace.push({
  step: 'fallback_to_canonical',
  reason: 'bestever_incomplete',
  albumTrackCount: 12,
  scraperEntriesCount: 8
})

// Salvar em Firestore
await db.collection('series/{id}/rankings/{albumId}').set({
  rankingConsolidated: [...],
  debugTrace: [...],
  timestamp: FieldValue.serverTimestamp()
})
```

**Risco**: ğŸŸ¢ **Baixo**
- Debug trace jÃ¡ implementado em v1.6.1
- Apenas precisa de persistÃªncia Firestore

#### 5.2 BotÃ£o "Atualizar aclamaÃ§Ã£o"
**Proposta**: Reprocessar por Ã¡lbum

**AvaliaÃ§Ã£o**: âœ… **Funcionalidade Ãºtil**

**ImplementaÃ§Ã£o**:
- Reutilizar endpoint existente `/api/generate`
- Atualizar cache Firestore apÃ³s reprocessamento

**Risco**: ğŸŸ¢ **Baixo**

---

### 6ï¸âƒ£ SÃ©ries de Playlists (1.3)

#### 6.1 Seletor de SÃ©rie
**Proposta**: Dropdown com sÃ©ries gravadas

**AvaliaÃ§Ã£o**: âœ… **Melhora organizaÃ§Ã£o**

**UI**:
```html
<select id="series-selector">
  <option value="default">SÃ©rie PadrÃ£o</option>
  <option value="series123">Classic Rock Collection</option>
  <option value="series456">90s Alternative</option>
</select>
```

**Risco**: ğŸŸ¢ **Baixo**

#### 6.2 Snapshot/Versionamento
**Proposta**: `series/{id}/history/{timestamp}` para revert

**AvaliaÃ§Ã£o**: âœ… **CrÃ­tico para confiabilidade**

**Schema**:
```javascript
// Collection: series/{id}/history
{
  timestamp: Timestamp,
  playlists: [...],  // Estado completo das playlists
  action: "manual_save" | "auto_save" | "drag_applied",
  user: "user@example.com"  // Se auth implementado
}
```

**Funcionalidade "Revert"**:
```javascript
async function revertToSnapshot(seriesId, snapshotId) {
  const snapshot = await db.doc(`series/${seriesId}/history/${snapshotId}`).get()
  await db.doc(`series/${seriesId}`).update({
    playlists: snapshot.data().playlists,
    updatedAt: FieldValue.serverTimestamp()
  })
}
```

**Risco**: ğŸŸ¡ **MÃ©dio**
- Snapshots podem crescer rapidamente (muitos saves)
- Custo Firestore reads/writes

**MitigaÃ§Ã£o**:
- Limitar histÃ³rico (Ãºltimos 10 snapshots)
- Auto-delete apÃ³s 30 dias
- Considerar compressÃ£o para snapshots antigos

---

### 7ï¸âƒ£ Deploy & MigraÃ§Ã£o

#### 7.1 AtualizaÃ§Ã£o de DocumentaÃ§Ã£o
**Proposta**: README, CHANGELOG, PROJECT_SUMMARY

**AvaliaÃ§Ã£o**: âœ… **Essencial**

**Checklist**:
- [ ] README: Adicionar seÃ§Ã£o "v2.0 Features"
- [ ] CHANGELOG: Criar seÃ§Ã£o "v2.0.0 Release"
- [ ] PROJECT_SUMMARY: Documentar nova arquitetura (stores, views)
- [ ] Criar `docs/MIGRATION_GUIDE.md` (v1.6 â†’ v2.0)

#### 7.2 Script de MigraÃ§Ã£o Firestore
**Proposta**: CLI para migrar playlists existentes

**AvaliaÃ§Ã£o**: âš ï¸ **CrÃ­tico mas complexo**

**ConsideraÃ§Ãµes**:
- **Estado atual**: Playlists armazenadas onde? (localStorage? Firestore?)
- **Se localStorage**: Script precisa rodar client-side ou pedir export manual
- **Se Firestore direto**: MigraÃ§Ã£o server-side mais simples

**Script exemplo** (assumindo Firestore existente):
```javascript
// migrate-to-v2.js
const admin = require('firebase-admin')
admin.initializeApp()
const db = admin.firestore()

async function migratePlaylistsToSeries() {
  // 1. Criar sÃ©rie padrÃ£o
  const defaultSeries = await db.collection('series').add({
    name: 'Default Series (Migrated from v1.6)',
    albumQueries: [],  // Popular manualmente
    createdAt: admin.firestore.FieldValue.serverTimestamp(),
    migrated: true
  })

  // 2. Mover playlists existentes
  const playlists = await db.collection('playlists').get()
  const batch = db.batch()
  
  playlists.forEach(doc => {
    const newRef = db.doc(`series/${defaultSeries.id}/playlists/${doc.id}`)
    batch.set(newRef, doc.data())
  })

  await batch.commit()
  console.log(`âœ… Migrated ${playlists.size} playlists to series/${defaultSeries.id}`)
}
```

**Risco**: ğŸ”´ **Alto**
- MigraÃ§Ã£o de dados sempre arriscada
- Pode causar perda de dados se falhar
- Rollback difÃ­cil

**MitigaÃ§Ã£o**:
- **Backup completo** antes da migraÃ§Ã£o
- Testar em ambiente de staging Firestore
- Implementar migraÃ§Ã£o _incremental_ (nÃ£o destrutiva)
  - Manter estrutura antiga por 1-2 meses
  - App detecta e migra on-demand
  - UsuÃ¡rio pode reverter se necessÃ¡rio

#### 7.3 Testes PrÃ©-Deploy
**Proposta**: `npm test` + deploy dry-run

**AvaliaÃ§Ã£o**: âœ… **MandatÃ³rio**

**Checklist prÃ©-deploy**:
```bash
# 1. Testes unitÃ¡rios
npm run test:unit

# 2. Testes de integraÃ§Ã£o
npm run test:integration

# 3. Build production
npm run build

# 4. Deploy staging
firebase use staging
firebase deploy

# 5. Smoke tests em staging
npm run test:e2e:staging

# 6. Deploy production (se tudo OK)
firebase use production
firebase deploy
```

**Risco**: ğŸŸ¡ **MÃ©dio**
- E2E tests podem ser flaky
- Deploy pode falhar parcialmente (frontend OK, backend fail)

**MitigaÃ§Ã£o**:
- Implementar health check endpoint
- Monitoring (Sentry, LogRocket)
- Feature flags para rollout gradual

---

## AnÃ¡lise de Riscos Consolidada

### Riscos TÃ©cnicos

| Risco | Probabilidade | Impacto | Severidade | MitigaÃ§Ã£o |
|-------|---------------|---------|------------|-----------|
| **MigraÃ§Ã£o Firestore com perda de dados** | ğŸŸ¡ MÃ©dia | ğŸ”´ Alto | ğŸ”´ **CrÃ­tico** | Backup + staging + rollback plan |
| **Performance com muitos Ã¡lbuns** | ğŸŸ¡ MÃ©dia | ğŸŸ¡ MÃ©dio | ğŸŸ¡ **MÃ©dio** | Client-side filtering â†’ server queries |
| **Rate limiting BestEverAlbums** | ğŸŸ¢ Baixa | ğŸŸ¡ MÃ©dio | ğŸŸ¡ **MÃ©dio** | Queue + retry logic + caching |
| **Complexidade sem framework** | ğŸŸ¡ MÃ©dia | ğŸŸ¡ MÃ©dio | ğŸŸ¡ **MÃ©dio** | Considerar Preact/Alpine.js |
| **Testes E2E flaky** | ğŸŸ¡ MÃ©dia | ğŸŸ¢ Baixo | ğŸŸ¢ **Baixo** | Retry + stable selectors |

### Riscos de Projeto

| Risco | Probabilidade | Impacto | Severidade | MitigaÃ§Ã£o |
|-------|---------------|---------|------------|-----------|
| **Scope creep** | ğŸ”´ Alta | ğŸŸ¡ MÃ©dio | ğŸŸ¡ **MÃ©dio** | MVP definido, features opcionais claras |
| **Breaking changes v1.6 â†’ v2.0** | ğŸŸ¡ MÃ©dia | ğŸ”´ Alto | ğŸ”´ **CrÃ­tico** | Migration guide + suporte v1.6 por perÃ­odo |
| **Tempo de desenvolvimento** | ğŸŸ¡ MÃ©dia | ğŸŸ¡ MÃ©dio | ğŸŸ¡ **MÃ©dio** | Entregas incrementais (Fases 1-7) |

---

## Roadmap Sugerido

### Sprint 1: FundaÃ§Ã£o (2 semanas)
- [ ] Setup Vite + Vitest
- [ ] Criar stores bÃ¡sicos (`albums.js`, `playlists.js`)
- [ ] Migrar `app.js` â†’ stores (sem quebrar funcionalidade)
- [ ] Testes unitÃ¡rios para stores
- [ ] **Entrega**: v2.0-alpha com stores funcionais

### Sprint 2: NavegaÃ§Ã£o (1 semana)
- [ ] Implementar HashRouter
- [ ] Criar views (`home.js`, `albums.js`, `ranking.js`, `playlists.js`)
- [ ] Componentizar TopNav
- [ ] **Entrega**: v2.0-beta1 com navegaÃ§Ã£o

### Sprint 3: Home & SÃ©ries (2 semanas)
- [ ] FormulÃ¡rio de criaÃ§Ã£o de sÃ©rie
- [ ] IntegraÃ§Ã£o Firestore (coleÃ§Ã£o `series`)
- [ ] Listagem de sÃ©ries recentes
- [ ] Endpoint `/api/batch-generate` (backend)
- [ ] **Entrega**: v2.0-beta2 com sÃ©ries

### Sprint 4: Ãlbuns & Ranking (1.5 semanas)
- [ ] View de Ã¡lbuns com filtros
- [ ] AÃ§Ãµes rÃ¡pidas (remover, reprocessar)
- [ ] View de ranking com tabs (Resumo, Fontes, Logs)
- [ ] Persistir `debugTrace` no Firestore
- [ ] **Entrega**: v2.0-beta3 com gestÃ£o de Ã¡lbuns

### Sprint 5: Playlists & Versionamento (1.5 semanas)
- [ ] Seletor de sÃ©rie no grid de playlists
- [ ] Snapshot/versionamento (`series/{id}/history`)
- [ ] UI de revert
- [ ] Badges de status ("Drag aplicado", "Sincronizado")
- [ ] **Entrega**: v2.0-rc1

### Sprint 6: MigraÃ§Ã£o & Testes (1 semana)
- [ ] Script de migraÃ§Ã£o Firestore
- [ ] Testes E2E (Playwright/Cypress)
- [ ] Migration guide
- [ ] Atualizar toda documentaÃ§Ã£o
- [ ] Deploy staging + validaÃ§Ã£o
- [ ] **Entrega**: v2.0.0 production-ready

**Total estimado**: ~9-10 semanas (~2.5 meses)

---

## RecomendaÃ§Ãµes Finais

### âœ… RecomendaÃ§Ãµes TÃ©cnicas

1. **Use Vite** (nÃ£o Rollup)
   - HMR superior, melhor DX
   - Config mÃ­nima para setup atual

2. **Implemente stores gradualmente**
   - ComeÃ§ar por `albums.js`
   - Manter `app.js` funcional atÃ© migraÃ§Ã£o completa
   - Evitar big-bang refactor

3. **Priorize testes de lÃ³gica pura**
   - `shared/normalize.js`
   - `CurationEngine`
   - Stores (sem DOM)
   - Deixar E2E para Sprint 6

4. **Considere micro-framework se complexidade crescer**
   - Preact (3KB) ou Alpine.js (15KB)
   - Evita reinventar roda (reactivity, componentes)
   - Ainda permite bundle pequeno

5. **Implemente feature flags**
   - Rollout gradual de v2.0
   - Permite rollback rÃ¡pido em produÃ§Ã£o
   - Firebase Remote Config integra bem

### âš ï¸ Pontos de AtenÃ§Ã£o

1. **MigraÃ§Ã£o Firestore Ã© o maior risco**
   - Testar EXAUSTIVAMENTE em staging
   - Ter plano de rollback documentado
   - Considerar migraÃ§Ã£o on-demand (lazy migration)

2. **NÃ£o subestime complexidade sem framework**
   - State management manual Ã© trabalhoso
   - Reavalie se escolha Ã© pragmÃ¡tica ou dogmÃ¡tica

3. **Performance com muitos Ã¡lbuns**
   - Client-side filtering OK para <100 Ã¡lbuns
   - Monitorar, migrar para Firestore queries se necessÃ¡rio

4. **BestEverAlbums rate limiting**
   - Implementar caching agressivo
   - Queue para batch processing
   - Considerar fallback providers

### ğŸ¯ MVP Recomendado para v2.0.0

**Incluir**:
- âœ… NavegaÃ§Ã£o por seÃ§Ãµes (HashRouter)
- âœ… Stores (albums, playlists, series)
- âœ… Home com criaÃ§Ã£o de sÃ©ries
- âœ… View de Ã¡lbuns (sem filtros avanÃ§ados)
- âœ… View de playlists com seletor de sÃ©rie
- âœ… PersistÃªncia Firestore bÃ¡sica

**Deixar para v2.1+**:
- â­ï¸ Filtros avanÃ§ados em Ã¡lbuns
- â­ï¸ Tabs de Fontes/Logs em Ranking
- â­ï¸ Versionamento com revert (implementar snapshot, mas UI de revert depois)
- â­ï¸ Feature flags
- â­ï¸ Telemetria avanÃ§ada

---

## ConclusÃ£o

O plano v2.0 Ã© **ambicioso mas viÃ¡vel**. A estrutura proposta Ã© sÃ³lida e alinha bem com as necessidades de crescimento da aplicaÃ§Ã£o.

### Pontos Fortes âœ…
- Arquitetura bem pensada (stores, views, components)
- Escolha de ferramentas adequadas (Vite, Vitest)
- Roadmap claro com entregas incrementais
- Foco em testes e observabilidade

### Principais Desafios âš ï¸
- MigraÃ§Ã£o Firestore requer planejamento cuidadoso
- RefatoraÃ§Ã£o de `app.js` Ã© grande (pode levar 2-3 semanas)
- Manter paridade funcional durante transiÃ§Ã£o
- Complexidade de state management sem framework

### PrÃ³ximos Passos Imediatos ğŸš€

1. âœ… **Concluir v1.6.1** (jÃ¡ feito!)
2. **Criar branch `feature/v2.0-foundation`**
3. **Setup Vite + Vitest** (Sprint 1, dia 1)
4. **Criar primeiro store** (`albums.js`)
5. **Projeto piloto**: Migrar uma feature pequena para validar arquitetura

**Estimativa realista**: v2.0.0 em produÃ§Ã£o em **2.5-3 meses** se dedicaÃ§Ã£o full-time.

---

**DÃºvidas?** Podemos detalhar qualquer fase especÃ­fica ou criar um plano de implementaÃ§Ã£o mais granular para o Sprint 1.
